/**
 * AdvancedFeatureService - é«˜åº¦ãªæ©Ÿèƒ½ã®å®Ÿè£…
 * 
 * - å®šæœŸè¦ç´„ï¼ˆ10åˆ†ã”ã¨ï¼‰
 * - èªå½™æŠ½å‡º
 * - æœ€çµ‚ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
 */

import { EventEmitter } from 'events';
import OpenAI from 'openai';
import { logger } from '../../utils/logger';
import { 
  createSummaryEvent,
  createProgressiveSummaryEvent,
  createErrorEvent,
  createVocabularyEvent,
  createFinalReportEvent
} from '../ipc/contracts';

interface AdvancedFeatureConfig {
  openaiApiKey: string;
  summaryInterval?: number; // Default: 10 minutes
  summaryModel?: string;    // Default: gpt-5-mini
  vocabularyModel?: string;  // Default: gpt-5-mini
  reportModel?: string;      // Default: gpt-5
  summaryThresholds?: number[]; // Default: [400, 800, 1600, 2400]
  maxTokens?: {
    summary?: number;
    vocabulary?: number;
    report?: number;
  };
  sourceLanguage?: string;  // è¬›ç¾©ã®è¨€èª
  targetLanguage?: string;  // ç¿»è¨³å…ˆè¨€èª
}

// Domain types for AdvancedFeatureService
interface Translation {
  id: string;
  original: string;
  translated: string;  // è¨€èªéä¾å­˜ã®åå‰ã«å¤‰æ›´
  timestamp: number;
}

interface Summary {
  id: string;
  timestamp: number;
  english: string;
  japanese: string;
  wordCount: number;
  startTime: number;
  endTime: number;
}

interface VocabularyItem {
  term: string;
  definition: string;
  context?: string;
}

export class AdvancedFeatureService extends EventEmitter {
  private openai: OpenAI;
  private config: Required<AdvancedFeatureConfig>;
  private summaryTimer: NodeJS.Timeout | null = null;
  private translations: Translation[] = [];
  private summaries: Summary[] = [];
  private isActive: boolean = false;
  private currentCorrelationId: string | null = null;
  private componentLogger = logger.child('AdvancedFeatureService');
  
  // æ®µéšçš„è¦ç´„ã®ãŸã‚ã®è¿½åŠ ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
  private totalWordCount: number = 0;
  private summaryThresholds: number[] = [400, 800, 1600, 2400];
  private reachedThresholds: Set<number> = new Set();
  
  // è¨€èªè¨­å®š
  private sourceLanguage: string = 'en';
  private targetLanguage: string = 'ja';
  private lastProgressiveSummary: string | null = null; // For cumulative summary
  private lastProgressiveThresholdIndex: number = -1; // Track last processed translation index
  
  // Progressive summary generation control
  private isGeneratingProgressiveSummary: boolean = false;
  private progressiveSummaryQueue: Array<{ baseThreshold: number; adjustedThreshold: number }> = [];
  
  constructor(config: AdvancedFeatureConfig) {
    super();
    
    this.config = {
      openaiApiKey: config.openaiApiKey,
      summaryInterval: config.summaryInterval ?? parseInt(process.env.SUMMARY_INTERVAL_MS || '600000'), // Default 10 minutes, can be overridden by env
      summaryModel: config.summaryModel ?? 'gpt-5-mini',
      vocabularyModel: config.vocabularyModel ?? 'gpt-5-mini',
      reportModel: config.reportModel ?? 'gpt-5',
      summaryThresholds: config.summaryThresholds ?? (process.env.TEST_MODE === 'true' ? [50, 100, 200, 400] : [400, 800, 1600, 2400]),
      maxTokens: {
        summary: config.maxTokens?.summary ?? 1500,
        vocabulary: config.maxTokens?.vocabulary ?? 1500,
        report: config.maxTokens?.report ?? 8192
      },
      sourceLanguage: config.sourceLanguage ?? 'en',
      targetLanguage: config.targetLanguage ?? 'ja'
    };
    
    this.sourceLanguage = this.config.sourceLanguage;
    this.targetLanguage = this.config.targetLanguage;
    
    // Update summaryThresholds after config is initialized
    this.summaryThresholds = this.config.summaryThresholds;
    
    this.openai = new OpenAI({
      apiKey: this.config.openaiApiKey
    });
  }
  
  /**
   * Start the advanced features service
   */
  start(correlationId: string, sourceLanguage?: string, targetLanguage?: string): void {
    if (this.isActive) {
      this.componentLogger.warn('AdvancedFeatureService already active');
      return;
    }
    
    this.isActive = true;
    this.currentCorrelationId = correlationId;
    this.translations = [];
    this.summaries = [];
    
    // Update languages if provided
    if (sourceLanguage) this.sourceLanguage = sourceLanguage;
    if (targetLanguage) this.targetLanguage = targetLanguage;
    
    // æ®µéšçš„è¦ç´„ã®ãƒªã‚»ãƒƒãƒˆ
    this.totalWordCount = 0;
    this.reachedThresholds.clear();
    this.lastProgressiveSummary = null;
    this.lastProgressiveThresholdIndex = -1;
    
    // Start periodic summary generation
    this.startPeriodicSummary();
    
    this.componentLogger.info('AdvancedFeatureService started', {
      correlationId,
      summaryInterval: this.config.summaryInterval
    });
  }
  
  /**
   * Stop the advanced features service
   */
  async stop(): Promise<void> {
    if (!this.isActive) return;
    
    this.isActive = false;
    
    // Stop periodic summary
    if (this.summaryTimer) {
      clearInterval(this.summaryTimer);
      this.summaryTimer = null;
    }
    
    // Generate final summary if we have content
    if (this.translations.length > 0) {
      await this.generateSummary(true);
    }
    
    this.componentLogger.info('AdvancedFeatureService stopped');
  }
  
  /**
   * Add a translation for processing
   */
  addTranslation(translation: Translation): void {
    if (!this.isActive) return;
    
    this.translations.push(translation);
    
    // Count words in SOURCE language for summary thresholds
    // This ensures consistent counting regardless of translation target
    const wordCount = this.countWords(translation.original, this.sourceLanguage);
    this.totalWordCount += wordCount;
    
    this.componentLogger.info('Translation added', {
      translationCount: this.translations.length,
      wordCount: wordCount,
      totalWordCount: this.totalWordCount,
      sourceLanguage: this.sourceLanguage,
      targetLanguage: this.targetLanguage
    });
    
    // Check progressive summary thresholds based on source word count
    // ğŸ”´ CRITICAL: éåŒæœŸå‡¦ç†ã‚’é©åˆ‡ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°
    // awaitã‚’ä½¿ã‚ãšã«setImmediateã§æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ã§å®Ÿè¡Œ
    // ã“ã‚Œã«ã‚ˆã‚Šç¿»è¨³å‡¦ç†ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„
    setImmediate(() => {
      this.checkProgressiveSummaryThresholds().catch(error => {
        this.componentLogger.error('Failed to check progressive summary thresholds', { error });
      });
    });
  }
  
  /**
   * Check if progressive summary thresholds are reached
   */
  private async checkProgressiveSummaryThresholds(): Promise<void> {
    // Adjust thresholds for character-based languages
    const isCharacterBased = this.isCharacterBasedLanguage(this.sourceLanguage);
    const multiplier = isCharacterBased ? parseInt(process.env.CHARACTER_LANGUAGE_MULTIPLIER || '4') : 1;
    
    for (const baseThreshold of this.summaryThresholds) {
      const threshold = baseThreshold * multiplier;
      
      if (this.totalWordCount >= threshold && !this.reachedThresholds.has(threshold)) {
        this.reachedThresholds.add(threshold);
        
        this.componentLogger.info('Progressive summary threshold reached', {
          baseThreshold,
          adjustedThreshold: threshold,
          totalWordCount: this.totalWordCount,
          sourceLanguage: this.sourceLanguage,
          isCharacterBased
        });
        
        // æ®µéšçš„è¦ç´„ã‚’ç”Ÿæˆ
        // ğŸ”´ CRITICAL: ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ã¦é †æ¬¡å‡¦ç†ã™ã‚‹
        this.enqueueProgressiveSummary(baseThreshold, threshold);
      }
    }
  }
  
  /**
   * Enqueue progressive summary generation
   */
  private enqueueProgressiveSummary(baseThreshold: number, adjustedThreshold: number): void {
    this.progressiveSummaryQueue.push({ baseThreshold, adjustedThreshold });
    
    // ã‚­ãƒ¥ãƒ¼ã‚’å‡¦ç†é–‹å§‹ï¼ˆã™ã§ã«å‡¦ç†ä¸­ã§ãªã„å ´åˆï¼‰
    if (!this.isGeneratingProgressiveSummary) {
      this.processProgressiveSummaryQueue();
    }
  }
  
  /**
   * Process progressive summary queue
   */
  private async processProgressiveSummaryQueue(): Promise<void> {
    if (this.isGeneratingProgressiveSummary || this.progressiveSummaryQueue.length === 0) {
      return;
    }
    
    this.isGeneratingProgressiveSummary = true;
    
    try {
      while (this.progressiveSummaryQueue.length > 0) {
        const { baseThreshold, adjustedThreshold } = this.progressiveSummaryQueue.shift()!;
        
        this.componentLogger.info('Processing progressive summary from queue', {
          baseThreshold,
          adjustedThreshold,
          remainingInQueue: this.progressiveSummaryQueue.length
        });
        
        // éåŒæœŸå‡¦ç†ã‚’å¾…æ©Ÿã—ã¦ç¢ºå®Ÿã«å®Œäº†ã•ã›ã‚‹
        await this.generateProgressiveSummary(baseThreshold, adjustedThreshold);
        
        // æ¬¡ã®è¦ç´„ç”Ÿæˆã¾ã§å°‘ã—å¾…æ©Ÿï¼ˆAPIè¼»è¼³ã‚’é¿ã‘ã‚‹ãŸã‚ï¼‰
        if (this.progressiveSummaryQueue.length > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    } finally {
      this.isGeneratingProgressiveSummary = false;
    }
  }
  
  /**
   * Start periodic summary generation
   */
  private startPeriodicSummary(): void {
    // Skip periodic summary if disabled
    if (process.env.DISABLE_PERIODIC_SUMMARY === 'true') {
      this.componentLogger.info('Periodic summary disabled by environment variable');
      return;
    }
    
    this.summaryTimer = setInterval(async () => {
      if (this.translations.length > 0) {
        await this.generateSummary(false);
      }
    }, this.config.summaryInterval);
  }
  
  /**
   * Generate a summary of recent translations
   */
  async generateSummary(isFinal: boolean = false): Promise<void> {
    if (this.translations.length === 0) return;
    
    const startTime = Date.now();
    const wordCount = this.translations.reduce(
      (sum, t) => sum + this.countWords(t.original, this.sourceLanguage), 
      0
    );
    
    this.componentLogger.info('Generating summary', {
      isFinal,
      wordCount,
      translationCount: this.translations.length,
      sourceLanguage: this.sourceLanguage,
      targetLanguage: this.targetLanguage
    });
    
    try {
      // For summary generation, use ONLY the original source content
      // This ensures summaries are based on actual lecture content, not translations
      const content = this.translations
        .map(t => t.original)
        .join(' ');
      
      const prompt = isFinal
        ? this.getFinalSummaryPrompt(content, wordCount)
        : this.getPeriodicSummaryPrompt(content, wordCount);
      
      // Generate summary
      // ğŸ”´ CRITICAL: responses.create ã‚’ä½¿ç”¨ï¼ˆchat.completions.createã§ã¯ãªã„ï¼‰
      // UnifiedPipelineService.tsã®æ­£ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã«æº–æ‹ 
      const response = await this.openai.responses.create({
        model: this.config.summaryModel,
        input: [
          {
            role: 'system',
            content: this.getSummarySystemPrompt()  // è¨€èªã«å¿œã˜ãŸãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä½¿ç”¨
          },
          { role: 'user', content: prompt }
        ],
        max_output_tokens: this.config.maxTokens.summary,
        reasoning: { effort: 'low' }  // è¦ç´„ã«ã¯å°‘ã—æ¨è«–ã‚’ä½¿ç”¨
      });
      
      const summaryTextInSourceLang = response.output_text || '';
      
      if (summaryTextInSourceLang) {
        // Translate summary to target language if needed
        const summaryTextInTargetLang = this.sourceLanguage !== this.targetLanguage 
          ? await this.translateToTargetLanguage(summaryTextInSourceLang)
          : summaryTextInSourceLang;
        
        const summary: Summary = {
          id: `summary-${Date.now()}`,
          timestamp: Date.now(),
          english: this.sourceLanguage === 'en' ? summaryTextInSourceLang : summaryTextInTargetLang,
          japanese: this.targetLanguage === 'ja' ? summaryTextInTargetLang : summaryTextInSourceLang,
          wordCount,
          startTime: this.translations[0].timestamp,
          endTime: this.translations[this.translations.length - 1].timestamp
        };
        
        this.summaries.push(summary);
        
        // Emit summary event
        if (this.currentCorrelationId) {
          const summaryEvent = createSummaryEvent(
            {
              english: summary.english,
              japanese: summary.japanese,
              wordCount,
              startTime: summary.startTime,
              endTime: summary.endTime
            },
            this.currentCorrelationId
          );
          
          this.emit('summaryGenerated', summaryEvent);
        }
        
        // Clear translations after summary (for periodic summaries)
        if (!isFinal) {
          this.translations = [];
        }
        
        this.componentLogger.info('Summary generated', {
          isFinal,
          wordCount,
          duration: Date.now() - startTime
        });
      }
      
    } catch (error) {
      this.componentLogger.error('Failed to generate summary', { error });
      
      if (this.currentCorrelationId) {
        const errorEvent = createErrorEvent(
          {
            code: 'SUMMARY_GENERATION_FAILED',
            message: 'Failed to generate summary',
            recoverable: true,
            details: error instanceof Error ? { message: error.message } : {}
          },
          this.currentCorrelationId
        );
        this.emit('error', errorEvent);
      }
    }
  }
  
  /**
   * Generate progressive summary at word count thresholds
   */
  async generateProgressiveSummary(baseThreshold: number, actualThreshold: number): Promise<void> {
    if (this.translations.length === 0) return;
    
    const startTime = Date.now();
    
    try {
      // Calculate content for this summary
      let translationsToInclude: Translation[] = [];
      let newContent = '';
      let actualWordCount = 0;
      
      if (this.lastProgressiveSummary) {
        // For cumulative summary, get only new translations since last summary
        translationsToInclude = this.translations.slice(this.lastProgressiveThresholdIndex + 1);
        newContent = translationsToInclude.map(t => t.original).join(' ');
        actualWordCount = translationsToInclude.reduce((sum, t) => sum + this.countWords(t.original, this.sourceLanguage), 0);
      } else {
        // For first summary, include all translations up to threshold
        for (let i = 0; i < this.translations.length; i++) {
          const translation = this.translations[i];
          const words = this.countWords(translation.original, this.sourceLanguage);
          if (actualWordCount + words <= actualThreshold) {
            translationsToInclude.push(translation);
            actualWordCount += words;
            this.lastProgressiveThresholdIndex = i;
          } else {
            break;
          }
        }
      }
      
      // Get prompt based on whether we have a previous summary
      const prompt = this.lastProgressiveSummary 
        ? this.getCumulativeProgressiveSummaryPrompt(this.lastProgressiveSummary, newContent, baseThreshold)
        : this.getProgressiveSummaryPrompt(translationsToInclude.map(t => t.original).join(' '), baseThreshold);
      
      // Generate summary
      const response = await this.openai.responses.create({
        model: this.config.summaryModel,
        input: [
          {
            role: 'system',
            content: this.getSummarySystemPrompt()
          },
          { role: 'user', content: prompt }
        ],
        max_output_tokens: this.config.maxTokens.summary,
        reasoning: { effort: 'low' }
      });
      
      const summaryTextInSourceLang = response.output_text || '';
      
      if (summaryTextInSourceLang) {
        // Translate summary to target language if needed
        const summaryTextInTargetLang = this.sourceLanguage !== this.targetLanguage 
          ? await this.translateToTargetLanguage(summaryTextInSourceLang)
          : summaryTextInSourceLang;
        
        const summary: Summary = {
          id: `summary-progressive-${baseThreshold}-${Date.now()}`,
          timestamp: Date.now(),
          english: this.sourceLanguage === 'en' ? summaryTextInSourceLang : summaryTextInTargetLang,
          japanese: this.targetLanguage === 'ja' ? summaryTextInTargetLang : summaryTextInSourceLang,
          wordCount: actualThreshold,
          startTime: translationsToInclude[0].timestamp,
          endTime: translationsToInclude[translationsToInclude.length - 1].timestamp
        };
        
        // Store this summary for next cumulative update
        this.lastProgressiveSummary = summaryTextInSourceLang;
        
        this.summaries.push(summary);
        
        // Emit progressive summary event
        if (this.currentCorrelationId) {
          const progressiveSummaryEvent = createProgressiveSummaryEvent(
            {
              english: summary.english,
              japanese: summary.japanese,
              wordCount: actualWordCount,
              threshold: baseThreshold,
              startTime: summary.startTime,
              endTime: summary.endTime
            },
            this.currentCorrelationId
          );
          
          this.emit('progressiveSummary', progressiveSummaryEvent);
        }
        
        this.componentLogger.info('Progressive summary generated', {
          baseThreshold,
          actualThreshold,
          actualWordCount,
          duration: Date.now() - startTime,
          isCumulative: !!this.lastProgressiveSummary
        });
      }
      
    } catch (error) {
      this.componentLogger.error('Failed to generate progressive summary', { error, baseThreshold });
    }
  }
  
  
  /**
   * Generate vocabulary list from content
   * This method both returns the vocabulary and emits an event
   */
  async generateVocabulary(): Promise<VocabularyItem[]> {
    if (this.translations.length === 0) return [];
    
    try {
      const content = this.translations
        .map(t => t.original)
        .join(' ');
      
      const prompt = this.getVocabularyPrompt(content);
      
      // ğŸ”´ CRITICAL: responses.create ã‚’ä½¿ç”¨ï¼ˆchat.completions.createã§ã¯ãªã„ï¼‰
      const response = await this.openai.responses.create({
        model: this.config.vocabularyModel,
        input: [
          {
            role: 'system',
            content: this.getVocabularySystemPrompt()
          },
          { role: 'user', content: prompt }
        ],
        max_output_tokens: this.config.maxTokens.vocabulary,
        reasoning: { effort: 'low' }
        // Note: response_format is not supported in responses API, JSON output is handled through prompt instructions
      });
      
      const vocabularyResponse = response.output_text || '[]';
      
      try {
        let vocabulary: VocabularyItem[];
        try {
          vocabulary = JSON.parse(vocabularyResponse) as VocabularyItem[];
        } catch {
          // Try to extract JSON from the response
          const jsonMatch = vocabularyResponse.match(/\[[\s\S]*\]/);
          if (jsonMatch) {
            vocabulary = JSON.parse(jsonMatch[0]) as VocabularyItem[];
          } else {
            vocabulary = [];
          }
        }
        
        if (Array.isArray(vocabulary) && vocabulary.length > 0) {
          // Emit vocabulary event
          if (this.currentCorrelationId) {
            const vocabEvent = createVocabularyEvent({
              items: vocabulary,
              totalTerms: vocabulary.length
            }, this.currentCorrelationId);
            this.emit('vocabularyGenerated', vocabEvent);
          }
        }
        
        return vocabulary;
      } catch (error) {
        this.componentLogger.error('Failed to parse vocabulary response', { error });
        return [];
      }
      
    } catch (error) {
      this.componentLogger.error('Failed to generate vocabulary', { error });
      return [];
    }
  }
  
  /**
   * Generate final report
   */
  /**
   * Generate final report
   * This method both returns the report and emits an event
   */
  async generateFinalReport(): Promise<string> {
    if (this.translations.length === 0 && this.summaries.length === 0) {
      return '';
    }
    
    try {
      const totalWordCount = this.translations.reduce(
        (sum, t) => sum + this.countWords(t.original, this.sourceLanguage), 
        0
      );
      
      // Use only source content for final report
      const content = this.translations
        .map(t => t.original)
        .join(' ');
      
      // Use appropriate language field based on target language
      const summariesContent = this.summaries
        .map(s => this.targetLanguage === 'ja' ? s.japanese : s.english)
        .join('\n\n');
      
      const vocabulary = await this.generateVocabulary();
      
      const prompt = this.getFinalReportPrompt(content, summariesContent, vocabulary, totalWordCount);
      
      // ğŸ”´ CRITICAL: responses.create ã‚’ä½¿ç”¨ï¼ˆchat.completions.createã§ã¯ãªã„ï¼‰
      const response = await this.openai.responses.create({
        model: this.config.reportModel,
        input: [
          {
            role: 'system',
            content: this.getFinalReportSystemPrompt()
          },
          { role: 'user', content: prompt }
        ],
        max_output_tokens: this.config.maxTokens.report,
        reasoning: { effort: 'high' }  // ãƒ¬ãƒãƒ¼ãƒˆã«ã¯é«˜åº¦ãªæ¨è«–ã‚’ä½¿ç”¨
      });
      
      const report = response.output_text || '';
      
      this.componentLogger.info('Final report generated', {
        wordCount: totalWordCount,
        summaryCount: this.summaries.length,
        vocabularyCount: vocabulary.length
      });
      
      // Emit final report event
      if (report && this.currentCorrelationId) {
        const reportEvent = createFinalReportEvent({
          report,
          totalWordCount,
          summaryCount: this.summaries.length,
          vocabularyCount: vocabulary.length
        }, this.currentCorrelationId);
        this.emit('finalReportGenerated', reportEvent);
      }
      
      return report;
      
    } catch (error) {
      this.componentLogger.error('Failed to generate final report', { error });
      return '';
    }
  }
  
  
  /**
   * Get progressive summary prompt based on threshold
   */
  private getProgressiveSummaryPrompt(content: string, threshold: number): string {
    const promptMap: { [key: number]: string } = {
      400: this.getProgressiveSummaryPromptForThreshold(content, 400),
      800: this.getProgressiveSummaryPromptForThreshold(content, 800),
      1600: this.getProgressiveSummaryPromptForThreshold(content, 1600),
      2400: this.getProgressiveSummaryPromptForThreshold(content, 2400)
    };
    
    return promptMap[threshold] || this.getPeriodicSummaryPrompt(content, threshold);
  }
  
  /**
   * Get periodic summary prompt
   */
  private getPeriodicSummaryPrompt(content: string, wordCount: number): string {
    const promptMap: { [key: string]: string } = {
      'ja': `ä»¥ä¸‹ã¯éå»10åˆ†é–“ã®è¬›ç¾©å†…å®¹ã§ã™ï¼ˆç´„${wordCount}èªï¼‰ã€‚
é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã‚’ç®‡æ¡æ›¸ãã§3-5å€‹ã«ã¾ã¨ã‚ã¦ãã ã•ã„ã€‚

è¬›ç¾©å†…å®¹ï¼š
${content}

è¦ç´„ã¯ä»¥ä¸‹ã®å½¢å¼ã§ï¼š
- ãƒã‚¤ãƒ³ãƒˆ1
- ãƒã‚¤ãƒ³ãƒˆ2
- ãƒã‚¤ãƒ³ãƒˆ3
ï¼ˆå¿…è¦ã«å¿œã˜ã¦è¿½åŠ ï¼‰`,
      'en': `The following is the lecture content from the past 10 minutes (approximately ${wordCount} words).
Please summarize the important points in 3-5 bullet points.

Lecture content:
${content}

Summary in the following format:
- Point 1
- Point 2
- Point 3
(Add more if necessary)`,
      'zh': `ä»¥ä¸‹æ˜¯è¿‡å»10åˆ†é’Ÿçš„è®²åº§å†…å®¹ï¼ˆçº¦${wordCount}è¯ï¼‰ã€‚
è¯·ç”¨ 3-5 ä¸ªè¦ç‚¹æ€»ç»“é‡è¦å†…å®¹ã€‚

è®²åº§å†…å®¹ï¼š
${content}

æŒ‰ä»¥ä¸‹æ ¼å¼æ€»ç»“ï¼š
- è¦ç‚¹1
- è¦ç‚¹2
- è¦ç‚¹3
ï¼ˆå¦‚éœ€è¦å¯æ·»åŠ æ›´å¤šï¼‰`
    };
    
    return promptMap[this.sourceLanguage] || promptMap['en'];
  }
  
  /**
   * Get final summary prompt
   */
  private getFinalSummaryPrompt(content: string, wordCount: number): string {
    const promptMap: { [key: string]: string } = {
      'ja': `ä»¥ä¸‹ã¯è¬›ç¾©å…¨ä½“ã®å†…å®¹ã§ã™ï¼ˆç´„${wordCount}èªï¼‰ã€‚
è¬›ç¾©ã®ä¸»è¦ãªãƒ†ãƒ¼ãƒã¨é‡è¦ãƒã‚¤ãƒ³ãƒˆã‚’åŒ…æ‹¬çš„ã«ã¾ã¨ã‚ã¦ãã ã•ã„ã€‚

è¬›ç¾©å†…å®¹ï¼š
${content}

ä»¥ä¸‹ã®æ§‹æˆã§ã¾ã¨ã‚ã¦ãã ã•ã„ï¼š
1. ä¸»è¦ãƒ†ãƒ¼ãƒï¼ˆ1-2æ–‡ï¼‰
2. é‡è¦ãƒã‚¤ãƒ³ãƒˆï¼ˆ3-5å€‹ï¼‰
3. çµè«–ã¾ãŸã¯è¦ç‚¹`,
      'en': `The following is the entire lecture content (approximately ${wordCount} words).
Please comprehensively summarize the main themes and key points of the lecture.

Lecture content:
${content}

Please organize the summary as follows:
1. Main themes (1-2 sentences)
2. Key points (3-5 items)
3. Conclusion or main takeaways`,
      'zh': `ä»¥ä¸‹æ˜¯æ•´ä¸ªè®²åº§å†…å®¹ï¼ˆçº¦${wordCount}è¯ï¼‰ã€‚
è¯·å…¨é¢æ€»ç»“è®²åº§çš„ä¸»è¦ä¸»é¢˜å’Œé‡ç‚¹ã€‚

è®²åº§å†…å®¹ï¼š
${content}

è¯·æŒ‰ä»¥ä¸‹ç»“æ„æ€»ç»“ï¼š
1. ä¸»è¦ä¸»é¢˜ï¼ˆ1-2å¥ï¼‰
2. é‡ç‚¹ï¼ˆ3-5é¡¹ï¼‰
3. ç»“è®ºæˆ–è¦ç‚¹`
    };
    
    return promptMap[this.sourceLanguage] || promptMap['en'];
  }
  
  /**
   * Translate text to target language
   */
  private async translateToTargetLanguage(text: string): Promise<string> {
    try {
      // ã‚½ãƒ¼ã‚¹è¨€èªã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨€èªãŒåŒã˜å ´åˆã¯ç¿»è¨³ä¸è¦
      if (this.sourceLanguage === this.targetLanguage) {
        return text;
      }
      
      // ğŸ”´ CRITICAL: ç´¯ç©è¦ç´„ã®ç¿»è¨³ã¯ä½å„ªå…ˆåº¦ã§å‡¦ç†
      // ãƒ¡ã‚¤ãƒ³ç¿»è¨³å‡¦ç†ã¸ã®å½±éŸ¿ã‚’æœ€å°åŒ–ã™ã‚‹ãŸã‚ã€ã‚ˆã‚Šé•·ã„å¾…æ©Ÿæ™‚é–“ã‚’è¨­å®š
      if (this.isGeneratingProgressiveSummary) {
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
      
      // ğŸ”´ CRITICAL: responses.create ã‚’ä½¿ç”¨ï¼ˆchat.completions.createã§ã¯ãªã„ï¼‰
      const response = await this.openai.responses.create({
        model: 'gpt-5-nano',
        input: [
          {
            role: 'system',
            content: this.getTranslationSystemPrompt()
          },
          { role: 'user', content: text }
        ],
        // temperature ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯å‰Šé™¤æ¸ˆã¿ï¼ˆGPT-5ã§ã¯1.0ã®ã¿ã‚µãƒãƒ¼ãƒˆï¼‰
        max_output_tokens: this.config.maxTokens.summary,
        reasoning: { effort: 'minimal' }  // å˜ç´”ãªç¿»è¨³ãªã®ã§æœ€å°é™ã®æ¨è«–
      });
      
      return response.output_text || text;
      
    } catch (error) {
      this.componentLogger.error('Failed to translate to target language', { error });
      return text;
    }
  }
  
  /**
   * Get current summaries
   */
  getSummaries(): Summary[] {
    return [...this.summaries];
  }
  
  /**
   * Get summary system prompt based on source language
   */
  private getSummarySystemPrompt(): string {
    const promptMap: { [key: string]: string } = {
      'ja': 'ã‚ãªãŸã¯è¬›ç¾©å†…å®¹ã‚’è¦ç´„ã™ã‚‹å°‚é–€å®¶ã§ã™ã€‚ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ã„è¦ç´„ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚',
      'en': 'You are an expert at summarizing lecture content. Create concise and clear summaries.',
      'zh': 'æ‚¨æ˜¯æ€»ç»“è®²åº§å†…å®¹çš„ä¸“å®¶ã€‚è¯·åˆ›å»ºç®€æ´æ˜äº†çš„æ‘˜è¦ã€‚',
      'es': 'Eres un experto en resumir contenidos de conferencias. Crea resÃºmenes concisos y claros.',
      'fr': 'Vous Ãªtes un expert dans la synthÃ¨se de contenu de cours. CrÃ©ez des rÃ©sumÃ©s concis et clairs.',
      'de': 'Sie sind ein Experte fÃ¼r die Zusammenfassung von Vorlesungsinhalten. Erstellen Sie prÃ¤gnante und klare Zusammenfassungen.',
      'ko': 'ê°•ì˜ ë‚´ìš© ìš”ì•½ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ê°„ê²°í•˜ê³  ëª…í™•í•œ ìš”ì•½ì„ ì‘ì„±í•´ì£¼ì„¸ìš”.',
      'pt': 'VocÃª Ã© um especialista em resumir conteÃºdo de palestras. Crie resumos concisos e claros.',
      'ru': 'Ğ’Ñ‹ ÑĞºÑĞ¿ĞµÑ€Ñ‚ Ğ¿Ğ¾ Ğ¾Ğ±Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ»ĞµĞºÑ†Ğ¸Ğ¾Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ°Ñ‚ĞµÑ€Ğ¸Ğ°Ğ»Ğ°. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ğ¹Ñ‚Ğµ ĞºÑ€Ğ°Ñ‚ĞºĞ¸Ğµ Ğ¸ Ğ¿Ğ¾Ğ½ÑÑ‚Ğ½Ñ‹Ğµ Ñ€ĞµĞ·ÑĞ¼Ğµ.',
      'it': 'Sei un esperto nel riassumere contenuti di lezioni. Crea riassunti concisi e chiari.',
      'ar': 'Ø£Ù†Øª Ø®Ø¨ÙŠØ± ÙÙŠ ØªÙ„Ø®ÙŠØµ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª. Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ø®ØµØ§Øª Ù…ÙˆØ¬Ø²Ø© ÙˆÙˆØ§Ø¶Ø­Ø©.',
      'hi': 'à¤†à¤ª à¤µà¥à¤¯à¤¾à¤–à¥à¤¯à¤¾à¤¨ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤•à¥‹ à¤¸à¤¾à¤°à¤¾à¤‚à¤¶à¤¿à¤¤ à¤•à¤°à¤¨à¥‡ à¤®à¥‡à¤‚ à¤µà¤¿à¤¶à¥‡à¤·à¤œà¥à¤ à¤¹à¥ˆà¤‚à¥¤ à¤¸à¤‚à¤•à¥à¤·à¤¿à¤ªà¥à¤¤ à¤”à¤° à¤¸à¥à¤ªà¤·à¥à¤Ÿ à¤¸à¤¾à¤°à¤¾à¤‚à¤¶ à¤¬à¤¨à¤¾à¤à¤‚à¥¤',
      'vi': 'Báº¡n lÃ  chuyÃªn gia tÃ³m táº¯t ná»™i dung bÃ i giáº£ng. Táº¡o cÃ¡c báº£n tÃ³m táº¯t ngáº¯n gá»n vÃ  rÃµ rÃ ng.',
      'th': 'à¸„à¸¸à¸“à¹€à¸›à¹‡à¸™à¸œà¸¹à¹‰à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸à¹ƒà¸™à¸à¸²à¸£à¸ªà¸£à¸¸à¸›à¹€à¸™à¸·à¹‰à¸­à¸«à¸²à¸à¸²à¸£à¸šà¸£à¸£à¸¢à¸²à¸¢ à¸ªà¸£à¹‰à¸²à¸‡à¸ªà¸£à¸¸à¸›à¸—à¸µà¹ˆà¸à¸£à¸°à¸Šà¸±à¸šà¹à¸¥à¸°à¸Šà¸±à¸”à¹€à¸ˆà¸™',
      'tr': 'Ders iÃ§eriÄŸini Ã¶zetleme konusunda uzmansÄ±nÄ±z. Ã–zlÃ¼ ve net Ã¶zetler oluÅŸturun.',
      'pl': 'JesteÅ› ekspertem w podsumowywaniu treÅ›ci wykÅ‚adÃ³w. TwÃ³rz zwiÄ™zÅ‚e i jasne podsumowania.'
    };
    
    return promptMap[this.sourceLanguage] || promptMap['en'];
  }
  
  /**
   * Get cumulative progressive summary prompt
   */
  private getCumulativeProgressiveSummaryPrompt(previousSummary: string, newContent: string, threshold: number): string {
    // Use English prompts for all languages - OpenAI handles multilingual content well
    const thresholdPrompts: { [key: number]: string } = {
      50: `Previous summary:
${previousSummary}

New content:
${newContent}

Create an updated summary that integrates the previous summary with the new content. Keep it concise and focused on the main points.`,
      100: `Previous summary:
${previousSummary}

New content:
${newContent}

Combine the previous summary with the new material to create a comprehensive summary. Include main topics, key points, and important developments.`,
      200: `Previous summary:
${previousSummary}

New content:
${newContent}

Create a detailed summary that considers the overall flow of the lecture. Include themes, concepts, arguments, and how the discussion has developed.`,
      400: `Previous summary:
${previousSummary}

New content:
${newContent}

Provide a complete summary of the entire lecture. Include main arguments, supporting details, key insights, and conclusions. Be thorough but well-structured.`
    };
    
    return thresholdPrompts[threshold] || thresholdPrompts[400];
  }
  
  /**
   * Get translation system prompt
   */
  private getTranslationSystemPrompt(): string {
    const languageNames: { [key: string]: string } = {
      'ja': 'Japanese', 'en': 'English', 'zh': 'Chinese', 'es': 'Spanish',
      'fr': 'French', 'de': 'German', 'ko': 'Korean', 'pt': 'Portuguese',
      'ru': 'Russian', 'it': 'Italian', 'ar': 'Arabic', 'hi': 'Hindi',
      'vi': 'Vietnamese', 'th': 'Thai', 'tr': 'Turkish', 'pl': 'Polish'
    };
    
    const sourceLang = languageNames[this.sourceLanguage] || 'English';
    const targetLang = languageNames[this.targetLanguage] || 'Japanese';
    
    return `Translate the following ${sourceLang} text into natural ${targetLang}. Output ONLY the translation, no explanations.`;
  }
  
  /**
   * Get vocabulary prompt based on target language
   */
  private getVocabularyPrompt(content: string): string {
    const promptMap: { [key: string]: string } = {
      'ja': `ä»¥ä¸‹ã®è¬›ç¾©å†…å®¹ã‹ã‚‰ã€é‡è¦ãªå°‚é–€ç”¨èªã‚’5-10å€‹æŠ½å‡ºã—ã€ãã‚Œãã‚Œã«ç°¡æ½”ãªå®šç¾©ã‚’ä»˜ã‘ã¦ãã ã•ã„ã€‚

è¬›ç¾©å†…å®¹ï¼š
${content}

ä»¥ä¸‹ã®JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š
[
  {
    "term": "ç”¨èª",
    "definition": "å®šç¾©",
    "context": "ä½¿ç”¨ã•ã‚ŒãŸæ–‡è„ˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰"
  }
]`,
      'en': `Extract 5-10 important technical terms from the following lecture content, and provide a concise definition for each.

Lecture content:
${content}

Output in the following JSON format:
[
  {
    "term": "term",
    "definition": "definition",
    "context": "context where it was used (optional)"
  }
]`,
      'zh': `ä»ä»¥ä¸‹è®²åº§å†…å®¹ä¸­æå– 5-10 ä¸ªé‡è¦çš„ä¸“ä¸šæœ¯è¯­ï¼Œå¹¶ä¸ºæ¯ä¸ªæœ¯è¯­æä¾›ç®€æ´çš„å®šä¹‰ã€‚

è®²åº§å†…å®¹ï¼š
${content}

ä»¥ä¸‹åˆ— JSON æ ¼å¼è¾“å‡ºï¼š
[
  {
    "term": "æœ¯è¯­",
    "definition": "å®šä¹‰",
    "context": "ä½¿ç”¨ä¸Šä¸‹æ–‡ï¼ˆå¯é€‰ï¼‰"
  }
]`
    };
    
    // ä»–ã®è¨€èªã¯è‹±èªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä½¿ç”¨
    return promptMap[this.sourceLanguage] || promptMap['en'];
  }
  
  /**
   * Get vocabulary system prompt
   */
  private getVocabularySystemPrompt(): string {
    return 'You are an expert at extracting key vocabulary from academic lectures. Output only valid JSON.';
  }
  
  /**
   * Get final report prompt based on target language
   */
  private getFinalReportPrompt(content: string, summariesContent: string, vocabulary: VocabularyItem[], totalWordCount: number): string {
    const wordCountRounded = Math.floor(totalWordCount / 100) * 100;
    const vocabList = vocabulary.map(v => `- ${v.term}: ${v.definition}`).join('\n');
    
    const promptMap: { [key: string]: string } = {
      'ja': `ä»¥ä¸‹ã¯${wordCountRounded}èªç¨‹åº¦ã®è¬›ç¾©ã®å†…å®¹ã§ã™ã€‚
é«˜æ ¡ç”Ÿã«ã‚‚ç†è§£ã—ã‚„ã™ã„å½¢ã§Markdownå½¢å¼ã®ãƒ¬ãƒãƒ¼ãƒˆã«ã¾ã¨ã‚ã¦ãã ã•ã„ã€‚

è¬›ç¾©å†…å®¹ï¼š
${content}

ã“ã‚Œã¾ã§ã®è¦ç´„ï¼š
${summariesContent}

é‡è¦ç”¨èªï¼š
${vocabList}

å¿…ãšã€æ¬¡ã®æ§‹æˆã§ä½œæˆã—ã¦ãã ã•ã„ï¼š
1. **æ¦‚è¦** - è¬›ç¾©å…¨ä½“ã®å†…å®¹ã‚’2-3æ–‡ã§
2. **ãƒˆãƒ”ãƒƒã‚¯ä¸€è¦§** - ç®‡æ¡æ›¸ãã§ä¸»è¦ãƒˆãƒ”ãƒƒã‚¯ã‚’åˆ—æŒ™
3. **ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆ** - é‡è¦ãƒã‚¤ãƒ³ãƒˆã‚’3-5å€‹
4. **é‡è¦ç”¨èª** - å°‚é–€ç”¨èªã¨ãã®èª¬æ˜
5. **Q&A / ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³** - ã‚‚ã—ã‚ã‚Œã°
6. **ã¾ã¨ã‚** - å­¦ã‚“ã ã“ã¨ã®è¦ç‚¹`,
      'en': `The following is a lecture of approximately ${wordCountRounded} words.
Please create a Markdown report that is easy to understand for high school students.

Lecture content:
${content}

Previous summaries:
${summariesContent}

Key vocabulary:
${vocabList}

Please create the report with the following structure:
1. **Overview** - Summarize the entire lecture in 2-3 sentences
2. **Topic List** - List the main topics in bullet points
3. **Key Points** - 3-5 important points
4. **Important Terms** - Technical terms with explanations
5. **Q&A / Discussion** - If applicable
6. **Conclusion** - Key takeaways`,
      'zh': `ä»¥ä¸‹æ˜¯çº¦ ${wordCountRounded} è¯çš„è®²åº§å†…å®¹ã€‚
è¯·åˆ›å»ºä¸€ä»½é«˜ä¸­ç”Ÿä¹Ÿèƒ½è½»æ¾ç†è§£çš„ Markdown æ ¼å¼æŠ¥å‘Šã€‚

è®²åº§å†…å®¹ï¼š
${content}

ä¹‹å‰çš„æ€»ç»“ï¼š
${summariesContent}

é‡è¦æœ¯è¯­ï¼š
${vocabList}

è¯·æŒ‰ç…§ä»¥ä¸‹ç»“æ„åˆ›å»ºï¼š
1. **æ¦‚è¿°** - ç”¨ 2-3 å¥è¯æ€»ç»“æ•´ä¸ªè®²åº§
2. **ä¸»é¢˜åˆ—è¡¨** - ç”¨é¡¹ç›®ç¬¦å·åˆ—å‡ºä¸»è¦ä¸»é¢˜
3. **å…³é”®è¦ç‚¹** - 3-5 ä¸ªé‡è¦è¦ç‚¹
4. **é‡è¦æœ¯è¯­** - ä¸“ä¸šæœ¯è¯­åŠå…¶è§£é‡Š
5. **é—®ç­”/è®¨è®º** - å¦‚æœé€‚ç”¨
6. **æ€»ç»“** - å­¦ä¹ è¦ç‚¹`
    };
    
    // ä»–ã®è¨€èªã¯è‹±èªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä½¿ç”¨
    return promptMap[this.sourceLanguage] || promptMap['en'];
  }
  
  /**
   * Get final report system prompt
   */
  private getFinalReportSystemPrompt(): string {
    const promptMap: { [key: string]: string } = {
      'ja': 'ã‚ãªãŸã¯æ•™è‚²ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å°‚é–€å®¶ã§ã™ã€‚å­¦ç”Ÿã«ã¨ã£ã¦åˆ†ã‹ã‚Šã‚„ã™ãã€å­¦ç¿’ã«å½¹ç«‹ã¤ãƒ¬ãƒãƒ¼ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚',
      'en': 'You are an educational content expert. Create reports that are easy for students to understand and helpful for learning.',
      'zh': 'æ‚¨æ˜¯æ•™è‚²å†…å®¹ä¸“å®¶ã€‚è¯·åˆ›å»ºå­¦ç”Ÿæ˜“äºç†è§£ä¸”æœ‰åŠ©äºå­¦ä¹ çš„æŠ¥å‘Šã€‚',
      'es': 'Eres un experto en contenido educativo. Crea informes que sean fÃ¡ciles de entender para los estudiantes y Ãºtiles para el aprendizaje.',
      'fr': 'Vous Ãªtes un expert en contenu Ã©ducatif. CrÃ©ez des rapports faciles Ã  comprendre pour les Ã©tudiants et utiles pour l\'apprentissage.',
      'de': 'Sie sind ein Experte fÃ¼r Bildungsinhalte. Erstellen Sie Berichte, die fÃ¼r Studenten leicht verstÃ¤ndlich und fÃ¼r das Lernen hilfreich sind.',
      'ko': 'ë‹¹ì‹ ì€ êµìœ¡ ì½˜í…ì¸  ì „ë¬¸ê°€ì…ë‹ˆë‹¤. í•™ìƒë“¤ì´ ì´í•´í•˜ê¸° ì‰½ê³  í•™ìŠµì— ë„ì›€ì´ ë˜ëŠ” ë³´ê³ ì„œë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.',
      'pt': 'VocÃª Ã© um especialista em conteÃºdo educacional. Crie relatÃ³rios fÃ¡ceis de entender para os estudantes e Ãºteis para a aprendizagem.',
      'ru': 'Ğ’Ñ‹ ÑĞºÑĞ¿ĞµÑ€Ñ‚ Ğ¿Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ¼Ñƒ ĞºĞ¾Ğ½Ñ‚ĞµĞ½Ñ‚Ñƒ. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ñ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ÑÑ‚ÑƒĞ´ĞµĞ½Ñ‚Ğ°Ğ¼ Ğ»ĞµĞ³ĞºĞ¾ Ğ¿Ğ¾Ğ½ÑÑ‚ÑŒ Ğ¸ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¿Ğ¾Ğ»ĞµĞ·Ğ½Ñ‹ Ğ´Ğ»Ñ Ğ¾Ğ±ÑƒÑ‡ĞµĞ½Ğ¸Ñ.',
      'it': 'Sei un esperto di contenuti educativi. Crea rapporti facili da capire per gli studenti e utili per l\'apprendimento.',
      'ar': 'Ø£Ù†Øª Ø®Ø¨ÙŠØ± ÙÙŠ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ. Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ ØªÙ‚Ø§Ø±ÙŠØ± Ø³Ù‡Ù„Ø© Ø§Ù„ÙÙ‡Ù… Ù„Ù„Ø·Ù„Ø§Ø¨ ÙˆÙ…ÙÙŠØ¯Ø© Ù„Ù„ØªØ¹Ù„Ù….',
      'hi': 'à¤†à¤ª à¤¶à¥ˆà¤•à¥à¤·à¤¿à¤• à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤•à¥‡ à¤µà¤¿à¤¶à¥‡à¤·à¤œà¥à¤ à¤¹à¥ˆà¤‚à¥¤ à¤›à¤¾à¤¤à¥à¤°à¥‹à¤‚ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¤®à¤à¤¨à¥‡ à¤®à¥‡à¤‚ à¤†à¤¸à¤¾à¤¨ à¤”à¤° à¤¸à¥€à¤–à¤¨à¥‡ à¤®à¥‡à¤‚ à¤®à¤¦à¤¦à¤—à¤¾à¤° à¤°à¤¿à¤ªà¥‹à¤°à¥à¤Ÿ à¤¬à¤¨à¤¾à¤à¤‚à¥¤',
      'vi': 'Báº¡n lÃ  chuyÃªn gia vá» ná»™i dung giÃ¡o dá»¥c. Táº¡o cÃ¡c bÃ¡o cÃ¡o dá»… hiá»ƒu cho sinh viÃªn vÃ  há»¯u Ã­ch cho viá»‡c há»c táº­p.',
      'th': 'à¸„à¸¸à¸“à¹€à¸›à¹‡à¸™à¸œà¸¹à¹‰à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸à¸”à¹‰à¸²à¸™à¹€à¸™à¸·à¹‰à¸­à¸«à¸²à¸à¸²à¸£à¸¨à¸¶à¸à¸©à¸² à¸ªà¸£à¹‰à¸²à¸‡à¸£à¸²à¸¢à¸‡à¸²à¸™à¸—à¸µà¹ˆà¸™à¸±à¸à¹€à¸£à¸µà¸¢à¸™à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆà¸‡à¹ˆà¸²à¸¢à¹à¸¥à¸°à¹€à¸›à¹‡à¸™à¸›à¸£à¸°à¹‚à¸¢à¸Šà¸™à¹Œà¸•à¹ˆà¸­à¸à¸²à¸£à¹€à¸£à¸µà¸¢à¸™à¸£à¸¹à¹‰',
      'tr': 'EÄŸitim iÃ§eriÄŸi uzmanÄ±sÄ±nÄ±z. Ã–ÄŸrencilerin kolayca anlayabileceÄŸi ve Ã¶ÄŸrenmeye yardÄ±mcÄ± raporlar oluÅŸturun.',
      'pl': 'JesteÅ› ekspertem w dziedzinie treÅ›ci edukacyjnych. TwÃ³rz raporty Å‚atwe do zrozumienia dla studentÃ³w i pomocne w nauce.'
    };
    
    return promptMap[this.sourceLanguage] || promptMap['en'];
  }
  
  /**
   * Get progressive summary prompt for specific threshold
   */
  private getProgressiveSummaryPromptForThreshold(content: string, threshold: number): string {
    const promptsMap: { [lang: string]: { [threshold: number]: string } } = {
      'ja': {
        400: `ã“ã‚Œã¾ã§ã®è¬›ç¾©å†…å®¹ï¼ˆç´„400èªï¼‰ã®å°å…¥éƒ¨åˆ†ã‚’ã¾ã¨ã‚ã¦ãã ã•ã„ã€‚
è¬›ç¾©ã®ä¸»é¡Œã¨åˆæœŸã®é‡è¦ãƒã‚¤ãƒ³ãƒˆã‚’2-3ç‚¹æŒ™ã’ã¦ãã ã•ã„ã€‚

è¬›ç¾©å†…å®¹ï¼š
${content}

ç°¡æ½”ã«è¦ç´„ã—ã¦ãã ã•ã„ã€‚`,
        800: `ã“ã‚Œã¾ã§ã®è¬›ç¾©å†…å®¹ï¼ˆç´„800èªï¼‰ã®å‰åŠéƒ¨åˆ†ã‚’ã¾ã¨ã‚ã¦ãã ã•ã„ã€‚
ä¸»è¦ãªãƒˆãƒ”ãƒƒã‚¯ã¨é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã‚’3-4ç‚¹æŒ™ã’ã¦ãã ã•ã„ã€‚

è¬›ç¾©å†…å®¹ï¼š
${content}

æ§‹é€ çš„ã«è¦ç´„ã—ã¦ãã ã•ã„ã€‚`,
        1600: `ã“ã‚Œã¾ã§ã®è¬›ç¾©å†…å®¹ï¼ˆç´„1600èªï¼‰ã®ä¸­é–“ã¾ã¨ã‚ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
ä¸»è¦ãƒ†ãƒ¼ãƒã€é‡è¦ãªæ¦‚å¿µã€ãã—ã¦è­°è«–ã®æµã‚Œã‚’æ•´ç†ã—ã¦ãã ã•ã„ã€‚

è¬›ç¾©å†…å®¹ï¼š
${content}

ä»¥ä¸‹ã®å½¢å¼ã§ã¾ã¨ã‚ã¦ãã ã•ã„ï¼š
1. ä¸»è¦ãƒ†ãƒ¼ãƒ
2. é‡è¦ãªæ¦‚å¿µï¼ˆ3-5å€‹ï¼‰
3. è­°è«–ã®æµã‚Œ`,
        2400: `ã“ã‚Œã¾ã§ã®è¬›ç¾©å†…å®¹ï¼ˆç´„2400èªï¼‰ã®åŒ…æ‹¬çš„ãªã¾ã¨ã‚ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
å…¨ä½“çš„ãªãƒ†ãƒ¼ãƒã€ä¸»è¦ãªè«–ç‚¹ã€é‡è¦ãªè©³ç´°ã‚’æ•´ç†ã—ã¦ãã ã•ã„ã€‚

è¬›ç¾©å†…å®¹ï¼š
${content}

ä»¥ä¸‹ã®å½¢å¼ã§ã¾ã¨ã‚ã¦ãã ã•ã„ï¼š
1. è¬›ç¾©ã®æ¦‚è¦
2. ä¸»è¦ãªè«–ç‚¹ï¼ˆ4-6å€‹ï¼‰
3. é‡è¦ãªè©³ç´°ã¨ä¾‹
4. ã“ã“ã¾ã§ã®çµè«–`
      },
      'en': {
        400: `Please summarize the introductory portion of the lecture so far (approximately 400 words).
Identify the main topic and 2-3 initial key points.

Lecture content:
${content}

Please provide a concise summary.`,
        800: `Please summarize the first half of the lecture so far (approximately 800 words).
Identify the main topics and 3-4 important points.

Lecture content:
${content}

Please provide a structured summary.`,
        1600: `Please create a mid-point summary of the lecture so far (approximately 1600 words).
Organize the main themes, important concepts, and flow of discussion.

Lecture content:
${content}

Please organize as follows:
1. Main themes
2. Important concepts (3-5 items)
3. Flow of discussion`,
        2400: `Please create a comprehensive summary of the lecture so far (approximately 2400 words).
Organize the overall themes, main arguments, and important details.

Lecture content:
${content}

Please organize as follows:
1. Lecture overview
2. Main arguments (4-6 items)
3. Important details and examples
4. Conclusions so far`
      },
      'zh': {
        400: `è¯·æ€»ç»“ç›®å‰ä¸ºæ­¢è®²åº§çš„å¼•è¨€éƒ¨åˆ†ï¼ˆçº¦400è¯ï¼‰ã€‚
ç¡®å®šä¸»é¢˜å’Œ 2-3 ä¸ªåˆå§‹è¦ç‚¹ã€‚

è®²åº§å†…å®¹ï¼š
${content}

è¯·æä¾›ç®€æ´çš„æ€»ç»“ã€‚`,
        800: `è¯·æ€»ç»“ç›®å‰ä¸ºæ­¢è®²åº§çš„å‰åŠéƒ¨åˆ†ï¼ˆçº¦800è¯ï¼‰ã€‚
ç¡®å®šä¸»è¦ä¸»é¢˜å’Œ 3-4 ä¸ªé‡è¦è¦ç‚¹ã€‚

è®²åº§å†…å®¹ï¼š
${content}

è¯·æä¾›ç»“æ„åŒ–çš„æ€»ç»“ã€‚`,
        1600: `è¯·åˆ›å»ºç›®å‰ä¸ºæ­¢è®²åº§çš„ä¸­æœŸæ€»ç»“ï¼ˆçº¦1600è¯ï¼‰ã€‚
æ•´ç†ä¸»è¦ä¸»é¢˜ã€é‡è¦æ¦‚å¿µå’Œè®¨è®ºæµç¨‹ã€‚

è®²åº§å†…å®¹ï¼š
${content}

è¯·æŒ‰ä»¥ä¸‹ç»“æ„æ•´ç†ï¼š
1. ä¸»è¦ä¸»é¢˜
2. é‡è¦æ¦‚å¿µï¼ˆ3-5é¡¹ï¼‰
3. è®¨è®ºæµç¨‹`,
        2400: `è¯·åˆ›å»ºç›®å‰ä¸ºæ­¢è®²åº§çš„å…¨é¢æ€»ç»“ï¼ˆçº¦2400è¯ï¼‰ã€‚
æ•´ç†æ•´ä½“ä¸»é¢˜ã€ä¸»è¦è®ºç‚¹å’Œé‡è¦ç»†èŠ‚ã€‚

è®²åº§å†…å®¹ï¼š
${content}

è¯·æŒ‰ä»¥ä¸‹ç»“æ„æ•´ç†ï¼š
1. è®²åº§æ¦‚è¿°
2. ä¸»è¦è®ºç‚¹ï¼ˆ4-6é¡¹ï¼‰
3. é‡è¦ç»†èŠ‚å’Œä¾‹å­
4. ç›®å‰çš„ç»“è®º`
      }
    };
    
    const langPrompts = promptsMap[this.sourceLanguage] || promptsMap['en'];
    return langPrompts[threshold] || this.getPeriodicSummaryPrompt(content, threshold);
  }
  
  /**
   * Count words based on language
   * For Japanese/Chinese: count characters (excluding punctuation)
   * For other languages: count space-separated words
   * 
   * NOTE: For summary thresholds, we always use the SOURCE language word count
   * to maintain consistency with the original content.
   */
  /**
   * Determine if a language is character-based (no spaces between words)
   */
  private isCharacterBasedLanguage(language: string): boolean {
    return language === 'ja' || language === 'zh';
  }

  private countWords(text: string, language: string): number {
    if (this.isCharacterBasedLanguage(language)) {
      // For Japanese/Chinese, count characters excluding common punctuation
      const cleanedText = text.replace(/[ã€‚ã€ï¼ï¼Ÿ,.!?\s]/g, '');
      return cleanedText.length;
    } else {
      // For other languages, count space-separated words
      return text.trim().split(/\s+/).filter(word => word.length > 0).length;
    }
  }

  /**
   * Destroy the service
   */
  destroy(): void {
    this.stop();
    this.removeAllListeners();
  }
}