diff --git a/src/hooks/useUnifiedPipeline.ts b/src/hooks/useUnifiedPipeline.ts
index 78e5e13..d60f7bb 100644
--- a/src/hooks/useUnifiedPipeline.ts
+++ b/src/hooks/useUnifiedPipeline.ts
@@ -17,13 +17,16 @@
 import { useState, useEffect, useCallback, useRef } from 'react';
 // Import from shared types
 import type { PipelineEvent } from '../shared/types/contracts';
-import { SyncedDisplayPair } from '../utils/SyncedRealtimeDisplayManager';
+import { SyncedRealtimeDisplayManager, SyncedDisplayPair } from '../utils/SyncedRealtimeDisplayManager';
 import { FlexibleHistoryGrouper, HistoryBlock, HistorySentence } from '../utils/FlexibleHistoryGrouper';
+import { IncrementalTextManager } from '../utils/IncrementalTextManager';
+import { StreamBatcher } from '../utils/StreamBatcher';
+import { TranslationTimeoutManager } from '../utils/TranslationTimeoutManager';
 import type { UnifiedEvent } from '../shared/types/ipcEvents';
 import { useSessionMemory } from './useSessionMemory';
-import { useAudioCapture } from './useAudioCapture';
-import { useRealtimeTranscription } from './useRealtimeTranscription';
-import { useTranslationQueue } from './useTranslationQueue';
+import type { IAudioProcessor, AudioProcessorMessage } from '../types/audio-processor.types';
+import { AudioWorkletProcessor } from '../infrastructure/audio/AudioWorkletProcessor';
+import { RealtimeDisplayPresenter } from '../presentation/presenters/RealtimeDisplayPresenter';
 
 // ThreeLineDisplay型の定義
 export interface ThreeLineDisplay {
@@ -140,19 +143,17 @@ interface UseUnifiedPipelineOptions {
   onStatusChange?: (status: string) => void;
   onTranslation?: (translation: Translation) => void;
   onSummary?: (summary: Summary) => void;
-  isEnabled?: boolean;
 }
 
 export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
   const {
-    sourceLanguage,
-    targetLanguage,
+    sourceLanguage = 'en',
+    targetLanguage = 'ja',
     className,
     onError,
     onStatusChange,
     onTranslation,
-    onSummary,
-    isEnabled = true
+    onSummary
   } = options;
 
   // SessionMemory hook for data persistence
@@ -187,15 +188,30 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
   });
   
   // 言語設定を状態として管理（動的更新対応）
-  const [currentSourceLanguage, setCurrentSourceLanguage] = useState(sourceLanguage);
-  const [currentTargetLanguage, setCurrentTargetLanguage] = useState(targetLanguage);
-  
-  // 履歴グルーパーに追加済みのIDを追跡（重複防止）
-  const addedToHistorySetRef = useRef<Set<string>>(new Set());
-  const addedToGrouperSetRef = useRef<Set<string>>(new Set());
+  // デフォルト値を設定して空文字列を防ぐ
+  const [currentSourceLanguage, setCurrentSourceLanguage] = useState(sourceLanguage || 'multi');
+  const [currentTargetLanguage, setCurrentTargetLanguage] = useState(targetLanguage || 'ja');
   
   // Manager instances
+  const displayManagerRef = useRef<SyncedRealtimeDisplayManager | null>(null);
   const historyGrouperRef = useRef<FlexibleHistoryGrouper | null>(null);
+  const originalTextManagerRef = useRef<IncrementalTextManager | null>(null);
+  const translationTextManagerRef = useRef<IncrementalTextManager | null>(null);
+  const streamBatcherRef = useRef<StreamBatcher | null>(null);
+  const translationTimeoutManagerRef = useRef<TranslationTimeoutManager | null>(null); // 翻訳タイムアウト管理
+  
+  // 高品質翻訳を格納するマップ（combinedId -> translation）
+  const highQualityTranslationsRef = useRef<Map<string, string>>(new Map());
+  
+  // 結合文管理用のマップ
+  const segmentTranslationMap = useRef<Map<string, { original: string; translation: string; combinedId?: string }>>(new Map());
+  const segmentToCombinedMap = useRef<Map<string, string>>(new Map());
+  
+  // パラグラフ管理用のマップ
+  const paragraphTranslationMap = useRef<Map<string, { original: string; translation: string; isParagraph?: boolean }>>(new Map());
+  
+  // 履歴グルーパーに追加済みのIDを追跡（重複防止）
+  const addedToGrouperSet = useRef<Set<string>>(new Set());
 
   // Refs for cleanup and correlation
   const cleanupFunctions = useRef<(() => void)[]>([]);
@@ -210,19 +226,60 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
   useEffect(() => {
     setCurrentOriginalRef.current = setCurrentOriginal;
     
-    // Original text manager is now handled by useRealtimeTranscription
+    // IncrementalTextManagerのコールバックも更新
+    if (originalTextManagerRef.current) {
+      originalTextManagerRef.current.setOnUpdate((text, isStable) => {
+        console.log('[TextManager] Original text update (dynamic):', text?.substring(0, 50), isStable);
+        setCurrentOriginal(text);
+      });
+    }
   }, [setCurrentOriginal]);
   
   useEffect(() => {
     setCurrentTranslationRef.current = setCurrentTranslation;
     
-    // Translation text manager is now handled by useRealtimeTranscription
+    // IncrementalTextManagerのコールバックも更新
+    if (translationTextManagerRef.current) {
+      translationTextManagerRef.current.setOnUpdate((text, isStable) => {
+        console.log('[TextManager] Translation text update (dynamic):', text?.substring(0, 50), isStable);
+        setCurrentTranslation(text);
+      });
+    }
     
+    // StreamBatcherのコールバックも更新
+    if (streamBatcherRef.current && translationTextManagerRef.current) {
+      streamBatcherRef.current.setOnBatch((batch) => {
+        if (translationTextManagerRef.current) {
+          translationTextManagerRef.current.update(batch);
+        }
+      });
+    }
   }, [setCurrentTranslation]);
   
   // Initialize Managers
   useEffect(() => {
-    // Display manager is now handled by useRealtimeTranscription hook
+    // Initialize SyncedRealtimeDisplayManager
+    if (!displayManagerRef.current) {
+      displayManagerRef.current = new SyncedRealtimeDisplayManager(
+        (pairs) => {
+          console.log('[DisplayFlow] SyncedRealtimeDisplayManager update:', {
+            pairCount: pairs.length,
+            pairs: pairs.map(p => ({
+              id: p.id,
+              position: p.display.position,
+              opacity: p.display.opacity,
+              originalText: p.original.text.substring(0, 30) + (p.original.text.length > 30 ? '...' : ''),
+              translationText: p.translation.text.substring(0, 30) + (p.translation.text.length > 30 ? '...' : ''),
+              isFinal: p.original.isFinal
+            }))
+          });
+          console.log('[SyncedRealtimeDisplayManager] Updating displayPairs:', pairs.length, pairs);
+          setDisplayPairs(pairs);
+        }
+      );
+    }
+    
+    // RealtimeDisplayServiceは使用しない（displayPairsから直接変換）
     
     // Initialize FlexibleHistoryGrouper
     if (!historyGrouperRef.current) {
@@ -239,16 +296,80 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
       );
     }
     
-    // Text managers are now handled by useRealtimeTranscription hook
+    // Initialize IncrementalTextManager for original text
+    if (!originalTextManagerRef.current) {
+      originalTextManagerRef.current = new IncrementalTextManager(
+        (text, isStable) => {
+          console.log('[TextManager] Original text update (init):', text?.substring(0, 50), isStable);
+          // 初期化時は直接setStateを使用（後でuseEffectで更新される）
+          setCurrentOriginal(text);
+        },
+        800 // 0.8秒で確定
+      );
+    }
     
+    // Initialize IncrementalTextManager for translation
+    if (!translationTextManagerRef.current) {
+      translationTextManagerRef.current = new IncrementalTextManager(
+        (text, isStable) => {
+          console.log('[TextManager] Translation text update (init):', text?.substring(0, 50), isStable);
+          // 初期化時は直接setStateを使用（後でuseEffectで更新される）
+          setCurrentTranslation(text);
+        },
+        1000 // 1秒で確定
+      );
+    }
     
-    // Translation timeout manager is now handled by useRealtimeTranscription hook
+    // Initialize StreamBatcher for translation streaming
+    if (!streamBatcherRef.current) {
+      streamBatcherRef.current = new StreamBatcher(
+        (batch) => {
+          if (translationTextManagerRef.current) {
+            translationTextManagerRef.current.update(batch);
+          }
+        },
+        {
+          minInterval: 100,
+          maxWait: 200,
+          minChars: 2
+        }
+      );
+    }
+    
+    // Initialize TranslationTimeoutManager
+    if (!translationTimeoutManagerRef.current) {
+      translationTimeoutManagerRef.current = new TranslationTimeoutManager({
+        defaultTimeout: 7000, // 7秒
+        enableDynamicTimeout: true,
+        maxTimeout: 10000 // 10秒
+      });
+    }
     
     return () => {
+      if (displayManagerRef.current) {
+        displayManagerRef.current.destroy();
+        displayManagerRef.current = null;
+      }
       if (historyGrouperRef.current) {
         historyGrouperRef.current.reset();
         historyGrouperRef.current = null;
       }
+      if (originalTextManagerRef.current) {
+        originalTextManagerRef.current.reset();
+        originalTextManagerRef.current = null;
+      }
+      if (translationTextManagerRef.current) {
+        translationTextManagerRef.current.reset();
+        translationTextManagerRef.current = null;
+      }
+      if (streamBatcherRef.current) {
+        streamBatcherRef.current.reset();
+        streamBatcherRef.current = null;
+      }
+      if (translationTimeoutManagerRef.current) {
+        translationTimeoutManagerRef.current.destroy();
+        translationTimeoutManagerRef.current = null;
+      }
     };
   }, []);
 
@@ -360,210 +481,58 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
     return window.univoice?.generateCorrelationId?.() || `hook-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
   }, []);
 
-  // Translation timeout handling is now managed by useRealtimeTranscription hook
+  // 履歴に追加済みのセグメントIDを追跡
+  const addedToHistorySet = useRef<Set<string>>(new Set());
 
-  // Audio capture hook
-  const {
-    isCapturing,
-    error: audioCaptureError,
-    startCapture,
-    stopCapture,
-    audioMetrics
-  } = useAudioCapture({
-    enabled: isEnabled,
-    onError: (error) => {
-      console.error('[useUnifiedPipeline] Audio capture error:', error);
-      setError(error.message);
-      if (onError) {
-        onError(error.message);
-      }
+  // Handle translation timeout
+  const handleTranslationTimeout = useCallback((segmentId: string) => {
+    console.log('[useUnifiedPipeline] Handling translation timeout for segment:', segmentId);
+    
+    // Get segment data
+    const segment = segmentTranslationMap.current.get(segmentId);
+    if (!segment || !segment.original) {
+      console.warn('[useUnifiedPipeline] Timeout for unknown segment:', segmentId);
+      return;
     }
-  });
-
-  // Real-time transcription hook
-  const {
-    currentTranscription,
-    pendingSegments,
-    displayManager: transcriptionDisplayManager,
-    textManager: transcriptionTextManager,
-    handleASREvent,
-    clearTranscription,
-    resetManagers: resetTranscriptionManagers,
-    setDisplayPairsCallback,
-    clearTranslationTimeout
-  } = useRealtimeTranscription({
-    enabled: isEnabled,
-    onSegmentComplete: (segmentId, text) => {
-      console.log('[useUnifiedPipeline] Segment complete:', segmentId, text);
-      // Segment tracking is now handled by useTranslationQueue
-    },
-    onTranslationTimeout: (segmentId, originalText) => {
-      console.log('[useUnifiedPipeline] Translation timeout:', segmentId);
-      // Add to history with timeout status
-      if (!addedToHistorySetRef.current.has(segmentId)) {
-        addedToHistorySetRef.current.add(segmentId);
-        
-        const translation: Translation = {
-          id: segmentId,
-          original: originalText,
-          japanese: '[翻訳タイムアウト]',
-          timestamp: Date.now(),
-          firstPaintMs: 0,
-          completeMs: 7000 // タイムアウト時間
-        };
-        
-        setHistory(prev => [...prev, translation]);
-        
-        // Add to flexible history grouper
-        if (historyGrouperRef.current && !addedToGrouperSetRef.current.has(segmentId)) {
-          historyGrouperRef.current.addSentence({
-            id: segmentId,
-            original: originalText,
-            translation: '[翻訳タイムアウト]',
-            timestamp: Date.now()
-          });
-          addedToGrouperSetRef.current.add(segmentId);
-        }
-      }
-      
-      // Segment map cleanup is now handled by useTranslationQueue
-    },
-    onError: (error) => {
-      console.error('[useUnifiedPipeline] Transcription error:', error);
-      setError(error.message);
-      if (onError) {
-        onError(error.message);
-      }
+    
+    // Mark as timeout in displays
+    if (displayManagerRef.current) {
+      displayManagerRef.current.updateTranslation('[翻訳タイムアウト]', segmentId);
+      displayManagerRef.current.completeTranslation(segmentId);
     }
-  });
-
-  // Connect display pairs callback from transcription hook
-  useEffect(() => {
-    setDisplayPairsCallback((pairs) => {
-      setDisplayPairs(pairs);
-    });
-  }, [setDisplayPairsCallback]);
-
-  // Update currentOriginal with transcription
-  useEffect(() => {
-    setCurrentOriginal(currentTranscription);
-  }, [currentTranscription]);
-
-  // Translation queue hook
-  const {
-    activeTranslations,
-    highQualityTranslations,
-    handleTranslationEvent,
-    clearTranslations,
-    resetBatcher,
-    registerSegmentMapping,
-    registerParagraphMapping,
-    getMappedId
-  } = useTranslationQueue({
-    enabled: isEnabled,
-    onTranslationComplete: (segmentId, translation, originalText) => {
-      console.log('[useUnifiedPipeline] Translation complete:', segmentId);
-      
-      // Clear translation timeout to prevent false timeout
-      const cleared = clearTranslationTimeout(segmentId);
-      if (cleared) {
-        console.log('[useUnifiedPipeline] Translation timeout cleared for:', segmentId);
-      }
-      
-      // Update display manager
-      if (transcriptionDisplayManager) {
-        transcriptionDisplayManager.completeTranslation(segmentId);
-      }
-
-      // Add to history
-      if (!addedToHistorySetRef.current.has(segmentId)) {
-        addedToHistorySetRef.current.add(segmentId);
-        
-        const translationObj: Translation = {
-          id: segmentId,
-          original: originalText,
-          japanese: translation,
-          timestamp: Date.now(),
-          firstPaintMs: 0,
-          completeMs: Date.now()
-        };
-        
-        setHistory(prev => {
-          const exists = prev.some(item => item.id === translationObj.id);
-          if (exists) {
-            console.log('[useUnifiedPipeline] Translation already in history, skipping:', translationObj.id);
-            return prev;
-          }
-          return [...prev, translationObj];
-        });
-        
-        if (onTranslation) {
-          onTranslation(translationObj);
-        }
-      }
-
-      // Segment map cleanup is now handled by useTranslationQueue
-    },
-    onHighQualityTranslation: (targetId, translationText, isParagraph) => {
-      console.log('[useUnifiedPipeline] High-quality translation received:', targetId, isParagraph);
+    
+    // Add to history with timeout status
+    if (!addedToHistorySet.current.has(segmentId)) {
+      addedToHistorySet.current.add(segmentId);
       
-      // Update in SessionMemory
-      if (isSessionActive && !isParagraph) {
-        try {
-          updateTranslation(targetId, {
-            japanese: translationText,
-            completeMs: Date.now()
-          });
-          console.log('[useUnifiedPipeline] Translation updated in session memory:', targetId);
-        } catch (error) {
-          console.error('[useUnifiedPipeline] Failed to update translation in session memory:', error);
-        }
-      }
+      const translation: Translation = {
+        id: segmentId,
+        original: segment.original,
+        japanese: '[翻訳タイムアウト]',
+        timestamp: Date.now(),
+        firstPaintMs: 0,
+        completeMs: 7000 // タイムアウト時間
+      };
       
-      // Update FlexibleHistoryGrouper
-      if (historyGrouperRef.current) {
-        if (isParagraph) {
-          historyGrouperRef.current.updateParagraphTranslation(targetId, translationText);
-          console.log('[useUnifiedPipeline] Updated FlexibleHistoryGrouper paragraph translation:', targetId);
-        } else {
-          historyGrouperRef.current.updateSentenceTranslation(targetId, translationText);
-          console.log('[useUnifiedPipeline] Updated FlexibleHistoryGrouper sentence translation:', targetId);
-        }
-      }
+      setHistory(prev => [...prev, translation]);
       
-      // Update history blocks
-      setHistoryBlocks(prevBlocks => {
-        return prevBlocks.map(block => {
-          const updatedSentences = block.sentences.map(sentence => {
-            if (sentence.id === targetId) {
-              console.log('[useUnifiedPipeline] Updating sentence translation:', sentence.id);
-              return {
-                ...sentence,
-                translation: translationText
-              };
-            }
-            return sentence;
-          });
-          
-          const hasUpdates = updatedSentences.some((s, i) => s.translation !== block.sentences[i].translation);
-          if (hasUpdates) {
-            return {
-              ...block,
-              sentences: updatedSentences
-            };
-          }
-          return block;
+      // Add to flexible history grouper
+      if (historyGrouperRef.current && !addedToGrouperSet.current.has(segmentId)) {
+        historyGrouperRef.current.addSentence({
+          id: segmentId,
+          original: segment.original,
+          translation: '[翻訳タイムアウト]',
+          timestamp: Date.now()
         });
-      });
-    },
-    onError: (error) => {
-      console.error('[useUnifiedPipeline] Translation queue error:', error);
-      setError(error.message);
-      if (onError) {
-        onError(error.message);
+        addedToGrouperSet.current.add(segmentId);
       }
     }
-  });
+    
+    // Clean up segment map
+    segmentTranslationMap.current.delete(segmentId);
+    
+    console.log('[useUnifiedPipeline] Translation timeout handled:', segmentId);
+  }, []);
 
   // Event handlers
   const handlePipelineEvent = useCallback((event: PipelineEvent) => {
@@ -573,47 +542,270 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
     // ASRイベントのデバッグログを強化
     if (event.type === 'asr') {
       console.log('[ASR DEBUG] Full event:', JSON.stringify(event, null, 2));
-      console.log('[ASR DEBUG] transcriptionDisplayManager exists:', !!transcriptionDisplayManager);
+      console.log('[ASR DEBUG] displayManagerRef exists:', !!displayManagerRef.current);
       console.log('[ASR DEBUG] displayPairs length:', displayPairs.length);
     }
 
     switch (event.type) {
       case 'asr':
-        // Delegate to real-time transcription hook
-        handleASREvent(event);
-        break;
-
-      case 'translation':
-        console.log('[useUnifiedPipeline] Translation event received:', {
-          segmentId: event.data.segmentId,
-          hasTranslation: !!event.data.translatedText,
+        console.log('[ASR] displayManagerRef.current:', !!displayManagerRef.current, 'segmentId:', event.data.segmentId);
+        console.log('[Display Debug] ASR Event:', {
+          text: event.data.text?.substring(0, 50) + '...',
           isFinal: event.data.isFinal,
-          textLength: event.data.translatedText?.length
+          currentOriginal: currentOriginal?.substring(0, 50) + '...'
         });
         
-        // Delegate to translation queue hook
-        handleTranslationEvent(event);
+        // Final結果の特別なログ
+        if (event.data.isFinal) {
+          console.log('[ASR FINAL] Final result received:', {
+            segmentId: event.data.segmentId,
+            textLength: event.data.text?.length,
+            text: event.data.text
+          });
+        }
         
-        // CRITICAL: Clear translation timeout immediately on any translation event
-        // This was the original behavior before refactoring
-        if (event.data.segmentId) {
-          const cleared = clearTranslationTimeout(event.data.segmentId);
-          if (cleared) {
-            console.log('[useUnifiedPipeline] Translation timeout cleared immediately for:', event.data.segmentId);
+        // Update display manager - now accepts interim results too
+        if (displayManagerRef.current) {
+          console.log('[ASR] Calling updateOriginal:', {
+            textLength: event.data.text?.length,
+            isFinal: event.data.isFinal,
+            segmentId: event.data.segmentId,
+            hasSegmentId: !!event.data.segmentId
+          });
+          displayManagerRef.current.updateOriginal(
+            event.data.text, 
+            event.data.isFinal, 
+            event.data.segmentId || `interim_${Date.now()}` // Provide segmentId even for interim
+          );
+          
+          // Track segment for translation pairing
+          if (event.data.isFinal) {
+            segmentTranslationMap.current.set(event.data.segmentId, {
+              original: event.data.text,
+              translation: ''
+            });
+            
+            // Start translation timeout
+            if (translationTimeoutManagerRef.current) {
+              translationTimeoutManagerRef.current.startTimeout(
+                event.data.segmentId,
+                event.data.text,
+                (timedOutSegmentId) => {
+                  console.log('[useUnifiedPipeline] Translation timeout for segment:', timedOutSegmentId);
+                  handleTranslationTimeout(timedOutSegmentId);
+                }
+              );
+            }
           }
+        } else {
+          console.warn('[ASR] Cannot update - displayManager:', !!displayManagerRef.current, 'segmentId:', event.data.segmentId);
+        }
+        
+        // Update current display (for compatibility)
+        if (originalTextManagerRef.current) {
+          console.log('[Display Debug] Updating currentOriginal:', event.data.text?.substring(0, 50) + '...', 'isFinal:', event.data.isFinal);
+          originalTextManagerRef.current.update(event.data.text);
         }
+        break;
+
+      case 'translation':
+        console.log('[useUnifiedPipeline] Translation event received:', event.data);
+        console.log('[useUnifiedPipeline] Translation text:', event.data.translatedText);
+        console.log('[useUnifiedPipeline] Translation text length:', event.data.translatedText?.length);
+        console.log('[useUnifiedPipeline] Translation text char codes (first 10):', 
+          event.data.translatedText ? [...event.data.translatedText.slice(0, 10)].map(c => c.charCodeAt(0)) : []);
         
-        // Update display with translation (handled by useRealtimeTranscription)
-        if (transcriptionDisplayManager && event.data.translatedText && event.data.segmentId) {
-          transcriptionDisplayManager.updateTranslation(
+        // 履歴用高品質翻訳またはパラグラフ翻訳の場合
+        if (event.data.segmentId && 
+            (event.data.segmentId.startsWith('history_') || 
+             event.data.segmentId.startsWith('paragraph_'))) {
+          const isParagraph = event.data.segmentId.startsWith('paragraph_');
+          console.log(`[useUnifiedPipeline] ${isParagraph ? 'Paragraph' : 'History'} translation received:`, event.data.segmentId);
+          
+          // プレフィックスを削除して元のIDを取得
+          const baseId = event.data.segmentId.replace(/^(history_|paragraph_)/, '');
+          
+          // パラグラフの場合はbaseIdをそのまま使用、履歴の場合はマッピングを確認
+          const targetId = isParagraph ? baseId : (segmentToCombinedMap.current.get(baseId) || baseId);
+          const translationText = event.data.translatedText || event.data.content;
+          
+          console.log(`[useUnifiedPipeline] Mapping ${isParagraph ? 'paragraph' : 'history'} translation:`, {
+            segmentId: event.data.segmentId,
+            baseId,
+            targetId,
+            isParagraph,
+            hasMapping: !isParagraph && segmentToCombinedMap.current.has(baseId)
+          });
+          
+          // 高品質翻訳を保存
+          if (translationText) {
+            highQualityTranslationsRef.current.set(targetId, translationText);
+            console.log('[useUnifiedPipeline] High-quality translation stored:', targetId, translationText.substring(0, 50));
+            
+            // SessionMemoryService: 高品質翻訳で更新
+            if (isSessionActive && !isParagraph) {
+              try {
+                updateTranslation(targetId, {
+                  japanese: translationText,
+                  completeMs: Date.now()
+                });
+                console.log('[useUnifiedPipeline] Translation updated in session memory:', targetId);
+              } catch (error) {
+                console.error('[useUnifiedPipeline] Failed to update translation in session memory:', error);
+              }
+            }
+            
+            // FlexibleHistoryGrouperの内部状態も更新
+            if (historyGrouperRef.current) {
+              if (isParagraph) {
+                // パラグラフの場合
+                historyGrouperRef.current.updateParagraphTranslation(targetId, translationText);
+                console.log('[useUnifiedPipeline] Updated FlexibleHistoryGrouper paragraph translation:', targetId);
+              } else {
+                // 文の場合（Phase 1修正）
+                historyGrouperRef.current.updateSentenceTranslation(targetId, translationText);
+                console.log('[useUnifiedPipeline] Updated FlexibleHistoryGrouper sentence translation:', targetId);
+              }
+            }
+            
+            // 既存の履歴ブロックを更新
+            setHistoryBlocks(prevBlocks => {
+              return prevBlocks.map(block => {
+                // 該当するセンテンスを含むブロックを探す
+                const updatedSentences = block.sentences.map(sentence => {
+                  if (sentence.id === targetId) {
+                    console.log('[useUnifiedPipeline] Updating sentence translation:', sentence.id);
+                    return {
+                      ...sentence,
+                      translation: translationText
+                    };
+                  }
+                  return sentence;
+                });
+                
+                // センテンスが更新された場合、ブロック全体を更新
+                const hasUpdates = updatedSentences.some((s, i) => s.translation !== block.sentences[i].translation);
+                if (hasUpdates) {
+                  return {
+                    ...block,
+                    sentences: updatedSentences
+                  };
+                }
+                return block;
+              });
+            });
+          }
+          
+          // 通常の翻訳処理はスキップ
+          break;
+        }
+        
+        // Clear translation timeout if exists
+        if (event.data.segmentId && translationTimeoutManagerRef.current) {
+          translationTimeoutManagerRef.current.clearTimeout(event.data.segmentId);
+        }
+        
+        // Update display with translation
+        if (displayManagerRef.current && event.data.translatedText && event.data.segmentId) {
+          displayManagerRef.current.updateTranslation(
             event.data.translatedText,
             event.data.segmentId
           );
+          
+          // Update segment map
+          const segment = segmentTranslationMap.current.get(event.data.segmentId);
+          if (segment) {
+            segment.translation = event.data.translatedText;
+          }
+        }
+        
+        // Handle translation completion
+        if (event.data.isFinal && event.data.segmentId) {
+          // Mark translation as complete (starts 1.5s removal timer)
+          if (displayManagerRef.current) {
+            displayManagerRef.current.completeTranslation(event.data.segmentId);
+          }
+          
+          // パラグラフ翻訳の場合
+          if (event.data.segmentId.startsWith('paragraph_')) {
+            const paragraphId = event.data.segmentId.replace('paragraph_', '');
+            const paragraphData = paragraphTranslationMap.current.get(paragraphId);
+            
+            if (paragraphData && historyGrouperRef.current) {
+              console.log('[DataFlow-12p] Updating paragraph translation:', {
+                paragraphId,
+                translationLength: event.data.translatedText.length
+              });
+              
+              // FlexibleHistoryGrouperのパラグラフ翻訳を更新
+              historyGrouperRef.current.updateParagraphTranslation(
+                paragraphId,
+                event.data.translatedText
+              );
+              
+              // マップも更新
+              paragraphData.translation = event.data.translatedText;
+            }
+            return; // パラグラフ翻訳の場合はここで処理終了
+          }
+          
+          // Get complete segment data
+          const segment = segmentTranslationMap.current.get(event.data.segmentId);
+          if (segment && segment.original && segment.translation) {
+            // Add to FlexibleHistoryGrouper
+            // 🔴 DISABLED: パラグラフモード優先のため、個別セグメントの履歴追加を無効化
+            // パラグラフ形成（20-60秒）を待つため、ここでは追加しない
+            /*
+            if (historyGrouperRef.current && !addedToGrouperSet.current.has(event.data.segmentId)) {
+              historyGrouperRef.current.addSentence({
+                id: event.data.segmentId,
+                original: segment.original,
+                translation: segment.translation,
+                timestamp: event.timestamp
+              });
+              addedToGrouperSet.current.add(event.data.segmentId);
+            }
+            */
+            
+            // Add to regular history (for backward compatibility)
+            if (!addedToHistorySet.current.has(event.data.segmentId)) {
+              addedToHistorySet.current.add(event.data.segmentId);
+              
+              const translation: Translation = {
+                id: event.data.segmentId,
+                original: event.data.originalText,
+                japanese: event.data.translatedText,
+                timestamp: event.timestamp,
+                firstPaintMs: 0,
+                completeMs: Date.now()
+              };
+              
+              setHistory(prev => {
+                const exists = prev.some(item => item.id === translation.id);
+                if (exists) {
+                  console.log('[useUnifiedPipeline] Translation already in history, skipping:', translation.id);
+                  return prev;
+                }
+                return [...prev, translation];
+              });
+              
+              if (onTranslation) {
+                onTranslation(translation);
+              }
+            }
+          }
+          
+          // Clean up segment map
+          segmentTranslationMap.current.delete(event.data.segmentId);
         }
         
         // Update current display for compatibility
-        if (event.data.translatedText) {
-          setCurrentTranslation(event.data.translatedText);
+        if (event.data.translatedText && translationTextManagerRef.current) {
+          console.log('[Display Debug] Updating currentTranslation (all events):', {
+            text: event.data.translatedText?.substring(0, 50) + '...',
+            isFinal: event.data.isFinal
+          });
+          translationTextManagerRef.current.update(event.data.translatedText);
         }
         break;
 
@@ -766,7 +958,13 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
           event.data.segmentIds.forEach((segmentId: string) => {
             console.log(`[DataFlow-12] Mapping segment ${segmentId} to combined ${event.data.combinedId}`);
             // セグメントIDと結合IDのマッピングを保存（後で履歴翻訳が来た時に使用）
-            registerSegmentMapping(segmentId, event.data.combinedId);
+            segmentTranslationMap.current.set(segmentId, {
+              original: event.data.originalText,
+              translation: '',
+              combinedId: event.data.combinedId  // 結合IDを追加
+            });
+            // 逆引きマップも保存（セグメントIDから結合IDを検索）
+            segmentToCombinedMap.current.set(segmentId, event.data.combinedId);
           });
           
           // 結合された文として履歴に追加
@@ -774,7 +972,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
           historyGrouperRef.current.addSentence({
             id: event.data.combinedId,
             original: event.data.originalText,
-            translation: '', // 空文字列に変更（Phase 1修正）
+            translation: '翻訳中...', // 翻訳待ちのプレースホルダー表示
             timestamp: event.data.timestamp
           });
           
@@ -877,7 +1075,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
       default:
         console.warn('[useUnifiedPipeline] Unknown event type:', event);
     }
-  }, [onError, onStatusChange, onTranslation, onSummary, isSessionActive, addTranslation, updateTranslation, addSummary, registerSegmentMapping, registerParagraphMapping, handleTranslationEvent, handleASREvent, transcriptionDisplayManager]);
+  }, [onError, onStatusChange, onTranslation, onSummary, isSessionActive, addTranslation, updateTranslation, addSummary]);
 
   // handlePipelineEventへの最新の参照を保持
   const handlePipelineEventRef = useRef(handlePipelineEvent);
@@ -904,7 +1102,9 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
       // 文字起こし結果の直接更新
       const originalUpdateHandler = (_event: any, data: any) => {
         console.log('[useUnifiedPipeline] current-original-update received:', data);
-        // Original text is now managed through transcription hook
+        if (originalTextManagerRef.current) {
+          originalTextManagerRef.current.update(data.text);
+        }
         setCurrentOriginal(data.text);
       };
       window.electron.on('current-original-update', originalUpdateHandler);
@@ -936,7 +1136,8 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
             timeRange: {
               start: summary.data.startTime || 0,
               end: summary.data.endTime || Date.now()
-            }
+            },
+            threshold: summary.data.threshold // Add threshold for progressive summaries
           };
           
           setSummaries(prev => {
@@ -997,7 +1198,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
       // SessionMemoryService: セッション開始
       // classNameがない場合はデフォルト値を使用
       const sessionClassName = className || `session_${new Date().toISOString().split('T')[0]}`;
-      if (!isSessionActive && currentSourceLanguage && currentTargetLanguage) {
+      if (!isSessionActive) {
         console.log('[useUnifiedPipeline] Starting new session:', sessionClassName);
         try {
           await startSession(sessionClassName, currentSourceLanguage, currentTargetLanguage);
@@ -1007,11 +1208,6 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
         }
       }
 
-      // Validate language settings
-      if (!currentSourceLanguage || !currentTargetLanguage) {
-        throw new Error('Language settings are required. Please configure them in Setup.');
-      }
-
       const result = await window.univoice?.startListening?.({
         sourceLanguage: currentSourceLanguage,
         targetLanguage: currentTargetLanguage,
@@ -1021,7 +1217,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
         throw new Error(result?.error || 'Failed to start pipeline');
       }
 
-      await startCapture(); // 成功したら音声キャプチャ開始
+      await startAudioCapture(); // 成功したら音声キャプチャ開始
 
       setIsRunning(true);
       setState(prev => ({ ...prev, status: 'listening', startTime: Date.now() }));
@@ -1037,7 +1233,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
         onError(msg);
       }
     }
-  }, [currentSourceLanguage, currentTargetLanguage, state.status, generateCorrelationId, onError, className, isSessionActive, startSession, startCapture]);
+  }, [currentSourceLanguage, currentTargetLanguage, state.status, generateCorrelationId, onError, className, isSessionActive, startSession]);
 
   const stop = useCallback(async () => {
     // レース防止
@@ -1055,7 +1251,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
         if (!result?.success) console.warn('[useUnifiedPipeline] Stop warning:', result?.error);
       }
 
-      stopCapture();
+      stopAudioCapture();
 
       // SessionMemoryService: セッション完了
       if (isSessionActive) {
@@ -1081,7 +1277,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
         onError(errorMsg);
       }
     }
-  }, [state.status, onError, isSessionActive, completeSession, stopCapture]);
+  }, [state.status, onError, isSessionActive, completeSession]);
 
   const translateUserInput = useCallback(async (text: string, from: string = 'ja', to: string = 'en'): Promise<string> => {
     try {
@@ -1111,6 +1307,126 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
     }
   }, [onError]);
 
+  // Audio capture functions
+  const audioContextRef = useRef<AudioContext | null>(null);
+  const mediaStreamRef = useRef<MediaStream | null>(null);
+  const processorRef = useRef<IAudioProcessor | null>(null);
+
+  const startAudioCapture = useCallback(async () => {
+    // 既に開始済みなら何もしない
+    if (audioContextRef.current || mediaStreamRef.current) {
+      console.warn('[useUnifiedPipeline] Audio capture already started');
+      return;
+    }
+
+    try {
+      const stream = await navigator.mediaDevices.getUserMedia({
+        audio: {
+          channelCount: 1,
+          sampleRate: 16000,           // 希望値（実際は無視されること有）
+          echoCancellation: true,
+          noiseSuppression: true,
+          autoGainControl: false
+        }
+      });
+      mediaStreamRef.current = stream;
+
+      // WebAudio 初期化
+      const ctx = new AudioContext({ sampleRate: 16000 });
+      audioContextRef.current = ctx;
+
+      const source = ctx.createMediaStreamSource(stream);
+
+      // Create AudioWorkletProcessor with type safety
+      let audioProcessCount = 0;
+      
+      const processor = await AudioWorkletProcessor.create(
+        ctx,
+        source,
+        (event: MessageEvent<AudioProcessorMessage>) => {
+          const { type, data } = event.data;
+
+          switch (type) {
+            case 'initialized':
+              console.log('[useUnifiedPipeline] AudioWorklet initialized:', data);
+              break;
+
+            case 'audio':
+              // PCM16データを受信
+              const pcm16 = new Int16Array(data.pcm16);
+              
+              audioProcessCount++;
+              if (audioProcessCount % 50 === 1) {
+                console.log('[useUnifiedPipeline] Audio processing:', {
+                  frameCount: audioProcessCount,
+                  pcm16Length: pcm16.length,
+                  sampleRate: data.sampleRate,
+                  timestamp: data.timestamp,
+                  hasElectronAPI: !!window.electron,
+                  hasSendAudioChunk: !!window.electron?.sendAudioChunk
+                });
+              }
+          
+              if (window.electron?.sendAudioChunk) {
+                window.electron.sendAudioChunk(pcm16);
+                
+                if (audioProcessCount % 50 === 1) {
+                  console.log('[useUnifiedPipeline] Sending audio chunk to main process');
+                }
+              } else {
+                if (audioProcessCount % 50 === 1) {
+                  console.error('[useUnifiedPipeline] Cannot send audio - electron API not available');
+                }
+              }
+              break;
+
+            case 'error':
+              console.error('[useUnifiedPipeline] AudioWorklet error:', data);
+              break;
+          }
+        },
+        {
+          targetSampleRate: 16000,
+          bufferSize: 512,
+          debug: false
+        }
+      );
+      
+      processorRef.current = processor;
+      console.log('[useUnifiedPipeline] Audio capture started. ctx.sampleRate=', ctx.sampleRate);
+    } catch (err) {
+      console.error('[useUnifiedPipeline] Audio capture failed:', err);
+      throw err;
+    }
+  }, []);
+
+  const stopAudioCapture = useCallback(() => {
+    try {
+      console.log('[useUnifiedPipeline] Stopping audio capture...');
+      
+      if (processorRef.current) {
+        // Use the type-safe destroy method
+        processorRef.current.destroy();
+        processorRef.current = null;
+      }
+      
+      if (audioContextRef.current) {
+        audioContextRef.current.close();
+        audioContextRef.current = null;
+      }
+      
+      if (mediaStreamRef.current) {
+        mediaStreamRef.current.getTracks().forEach(track => track.stop());
+        mediaStreamRef.current = null;
+      }
+      
+      console.log('[useUnifiedPipeline] Audio capture stopped');
+      
+    } catch (err: any) {
+      console.error('[useUnifiedPipeline] Audio capture stop failed:', err);
+    }
+  }, []);
+
   // Clear functions
   const clearHistory = useCallback(() => {
     setHistory([]);
@@ -1137,19 +1453,21 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
       setCurrentOriginal('');
       setCurrentTranslation('');
       setDisplayPairs([]);
-      clearTranslations(); // Clear translation queue data
-      addedToHistorySetRef.current.clear(); // 履歴追加済みセットもクリア
-      addedToGrouperSetRef.current.clear(); // グルーパー追加済みセットもクリア
+      segmentTranslationMap.current.clear();
+      addedToHistorySet.current.clear(); // 履歴追加済みセットもクリア
+      addedToGrouperSet.current.clear(); // グルーパー追加済みセットもクリア
       
       // Reset managers
-      resetTranscriptionManagers(); // Reset transcription-related managers
+      if (displayManagerRef.current) {
+        displayManagerRef.current.reset();
+      }
       if (historyGrouperRef.current) {
         historyGrouperRef.current.reset();
       }
     } catch (err: any) {
       console.error('[useUnifiedPipeline] Clear all failed:', err);
     }
-  }, [clearHistory, clearSummaries, clearError, resetTranscriptionManagers, clearTranslations]);
+  }, [clearHistory, clearSummaries, clearError]);
 
   // Generate vocabulary from current session
   const generateVocabulary = useCallback(async () => {
@@ -1220,7 +1538,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
     currentOriginal,
     currentTranslation,
     displayPairs,
-    threeLineDisplay,
+    threeLineDisplay: RealtimeDisplayPresenter.createThreeLineDisplay(displayPairs),
     historyBlocks,
     groupedHistory: (() => {
       // Convert history to 3-item groups for legacy compatibility
