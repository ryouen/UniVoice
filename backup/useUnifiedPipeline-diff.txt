diff --git a/src/hooks/useUnifiedPipeline.ts b/src/hooks/useUnifiedPipeline.ts
index 78e5e13..d60f7bb 100644
--- a/src/hooks/useUnifiedPipeline.ts
+++ b/src/hooks/useUnifiedPipeline.ts
@@ -17,13 +17,16 @@
 import { useState, useEffect, useCallback, useRef } from 'react';
 // Import from shared types
 import type { PipelineEvent } from '../shared/types/contracts';
-import { SyncedDisplayPair } from '../utils/SyncedRealtimeDisplayManager';
+import { SyncedRealtimeDisplayManager, SyncedDisplayPair } from '../utils/SyncedRealtimeDisplayManager';
 import { FlexibleHistoryGrouper, HistoryBlock, HistorySentence } from '../utils/FlexibleHistoryGrouper';
+import { IncrementalTextManager } from '../utils/IncrementalTextManager';
+import { StreamBatcher } from '../utils/StreamBatcher';
+import { TranslationTimeoutManager } from '../utils/TranslationTimeoutManager';
 import type { UnifiedEvent } from '../shared/types/ipcEvents';
 import { useSessionMemory } from './useSessionMemory';
-import { useAudioCapture } from './useAudioCapture';
-import { useRealtimeTranscription } from './useRealtimeTranscription';
-import { useTranslationQueue } from './useTranslationQueue';
+import type { IAudioProcessor, AudioProcessorMessage } from '../types/audio-processor.types';
+import { AudioWorkletProcessor } from '../infrastructure/audio/AudioWorkletProcessor';
+import { RealtimeDisplayPresenter } from '../presentation/presenters/RealtimeDisplayPresenter';
 
 // ThreeLineDisplayå‹ã®å®šç¾©
 export interface ThreeLineDisplay {
@@ -140,19 +143,17 @@ interface UseUnifiedPipelineOptions {
   onStatusChange?: (status: string) => void;
   onTranslation?: (translation: Translation) => void;
   onSummary?: (summary: Summary) => void;
-  isEnabled?: boolean;
 }
 
 export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
   const {
-    sourceLanguage,
-    targetLanguage,
+    sourceLanguage = 'en',
+    targetLanguage = 'ja',
     className,
     onError,
     onStatusChange,
     onTranslation,
-    onSummary,
-    isEnabled = true
+    onSummary
   } = options;
 
   // SessionMemory hook for data persistence
@@ -187,15 +188,30 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
   });
   
   // è¨€èªè¨­å®šã‚’çŠ¶æ…‹ã¨ã—ã¦ç®¡ç†ï¼ˆå‹•çš„æ›´æ–°å¯¾å¿œï¼‰
-  const [currentSourceLanguage, setCurrentSourceLanguage] = useState(sourceLanguage);
-  const [currentTargetLanguage, setCurrentTargetLanguage] = useState(targetLanguage);
-  
-  // å±¥æ­´ã‚°ãƒ«ãƒ¼ãƒ‘ãƒ¼ã«è¿½åŠ æ¸ˆã¿ã®IDã‚’è¿½è·¡ï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
-  const addedToHistorySetRef = useRef<Set<string>>(new Set());
-  const addedToGrouperSetRef = useRef<Set<string>>(new Set());
+  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®šã—ã¦ç©ºæ–‡å­—åˆ—ã‚’é˜²ã
+  const [currentSourceLanguage, setCurrentSourceLanguage] = useState(sourceLanguage || 'multi');
+  const [currentTargetLanguage, setCurrentTargetLanguage] = useState(targetLanguage || 'ja');
   
   // Manager instances
+  const displayManagerRef = useRef<SyncedRealtimeDisplayManager | null>(null);
   const historyGrouperRef = useRef<FlexibleHistoryGrouper | null>(null);
+  const originalTextManagerRef = useRef<IncrementalTextManager | null>(null);
+  const translationTextManagerRef = useRef<IncrementalTextManager | null>(null);
+  const streamBatcherRef = useRef<StreamBatcher | null>(null);
+  const translationTimeoutManagerRef = useRef<TranslationTimeoutManager | null>(null); // ç¿»è¨³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç®¡ç†
+  
+  // é«˜å“è³ªç¿»è¨³ã‚’æ ¼ç´ã™ã‚‹ãƒãƒƒãƒ—ï¼ˆcombinedId -> translationï¼‰
+  const highQualityTranslationsRef = useRef<Map<string, string>>(new Map());
+  
+  // çµåˆæ–‡ç®¡ç†ç”¨ã®ãƒãƒƒãƒ—
+  const segmentTranslationMap = useRef<Map<string, { original: string; translation: string; combinedId?: string }>>(new Map());
+  const segmentToCombinedMap = useRef<Map<string, string>>(new Map());
+  
+  // ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç®¡ç†ç”¨ã®ãƒãƒƒãƒ—
+  const paragraphTranslationMap = useRef<Map<string, { original: string; translation: string; isParagraph?: boolean }>>(new Map());
+  
+  // å±¥æ­´ã‚°ãƒ«ãƒ¼ãƒ‘ãƒ¼ã«è¿½åŠ æ¸ˆã¿ã®IDã‚’è¿½è·¡ï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
+  const addedToGrouperSet = useRef<Set<string>>(new Set());
 
   // Refs for cleanup and correlation
   const cleanupFunctions = useRef<(() => void)[]>([]);
@@ -210,19 +226,60 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
   useEffect(() => {
     setCurrentOriginalRef.current = setCurrentOriginal;
     
-    // Original text manager is now handled by useRealtimeTranscription
+    // IncrementalTextManagerã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚‚æ›´æ–°
+    if (originalTextManagerRef.current) {
+      originalTextManagerRef.current.setOnUpdate((text, isStable) => {
+        console.log('[TextManager] Original text update (dynamic):', text?.substring(0, 50), isStable);
+        setCurrentOriginal(text);
+      });
+    }
   }, [setCurrentOriginal]);
   
   useEffect(() => {
     setCurrentTranslationRef.current = setCurrentTranslation;
     
-    // Translation text manager is now handled by useRealtimeTranscription
+    // IncrementalTextManagerã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚‚æ›´æ–°
+    if (translationTextManagerRef.current) {
+      translationTextManagerRef.current.setOnUpdate((text, isStable) => {
+        console.log('[TextManager] Translation text update (dynamic):', text?.substring(0, 50), isStable);
+        setCurrentTranslation(text);
+      });
+    }
     
+    // StreamBatcherã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚‚æ›´æ–°
+    if (streamBatcherRef.current && translationTextManagerRef.current) {
+      streamBatcherRef.current.setOnBatch((batch) => {
+        if (translationTextManagerRef.current) {
+          translationTextManagerRef.current.update(batch);
+        }
+      });
+    }
   }, [setCurrentTranslation]);
   
   // Initialize Managers
   useEffect(() => {
-    // Display manager is now handled by useRealtimeTranscription hook
+    // Initialize SyncedRealtimeDisplayManager
+    if (!displayManagerRef.current) {
+      displayManagerRef.current = new SyncedRealtimeDisplayManager(
+        (pairs) => {
+          console.log('[DisplayFlow] SyncedRealtimeDisplayManager update:', {
+            pairCount: pairs.length,
+            pairs: pairs.map(p => ({
+              id: p.id,
+              position: p.display.position,
+              opacity: p.display.opacity,
+              originalText: p.original.text.substring(0, 30) + (p.original.text.length > 30 ? '...' : ''),
+              translationText: p.translation.text.substring(0, 30) + (p.translation.text.length > 30 ? '...' : ''),
+              isFinal: p.original.isFinal
+            }))
+          });
+          console.log('[SyncedRealtimeDisplayManager] Updating displayPairs:', pairs.length, pairs);
+          setDisplayPairs(pairs);
+        }
+      );
+    }
+    
+    // RealtimeDisplayServiceã¯ä½¿ç”¨ã—ãªã„ï¼ˆdisplayPairsã‹ã‚‰ç›´æ¥å¤‰æ›ï¼‰
     
     // Initialize FlexibleHistoryGrouper
     if (!historyGrouperRef.current) {
@@ -239,16 +296,80 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
       );
     }
     
-    // Text managers are now handled by useRealtimeTranscription hook
+    // Initialize IncrementalTextManager for original text
+    if (!originalTextManagerRef.current) {
+      originalTextManagerRef.current = new IncrementalTextManager(
+        (text, isStable) => {
+          console.log('[TextManager] Original text update (init):', text?.substring(0, 50), isStable);
+          // åˆæœŸåŒ–æ™‚ã¯ç›´æ¥setStateã‚’ä½¿ç”¨ï¼ˆå¾Œã§useEffectã§æ›´æ–°ã•ã‚Œã‚‹ï¼‰
+          setCurrentOriginal(text);
+        },
+        800 // 0.8ç§’ã§ç¢ºå®š
+      );
+    }
     
+    // Initialize IncrementalTextManager for translation
+    if (!translationTextManagerRef.current) {
+      translationTextManagerRef.current = new IncrementalTextManager(
+        (text, isStable) => {
+          console.log('[TextManager] Translation text update (init):', text?.substring(0, 50), isStable);
+          // åˆæœŸåŒ–æ™‚ã¯ç›´æ¥setStateã‚’ä½¿ç”¨ï¼ˆå¾Œã§useEffectã§æ›´æ–°ã•ã‚Œã‚‹ï¼‰
+          setCurrentTranslation(text);
+        },
+        1000 // 1ç§’ã§ç¢ºå®š
+      );
+    }
     
-    // Translation timeout manager is now handled by useRealtimeTranscription hook
+    // Initialize StreamBatcher for translation streaming
+    if (!streamBatcherRef.current) {
+      streamBatcherRef.current = new StreamBatcher(
+        (batch) => {
+          if (translationTextManagerRef.current) {
+            translationTextManagerRef.current.update(batch);
+          }
+        },
+        {
+          minInterval: 100,
+          maxWait: 200,
+          minChars: 2
+        }
+      );
+    }
+    
+    // Initialize TranslationTimeoutManager
+    if (!translationTimeoutManagerRef.current) {
+      translationTimeoutManagerRef.current = new TranslationTimeoutManager({
+        defaultTimeout: 7000, // 7ç§’
+        enableDynamicTimeout: true,
+        maxTimeout: 10000 // 10ç§’
+      });
+    }
     
     return () => {
+      if (displayManagerRef.current) {
+        displayManagerRef.current.destroy();
+        displayManagerRef.current = null;
+      }
       if (historyGrouperRef.current) {
         historyGrouperRef.current.reset();
         historyGrouperRef.current = null;
       }
+      if (originalTextManagerRef.current) {
+        originalTextManagerRef.current.reset();
+        originalTextManagerRef.current = null;
+      }
+      if (translationTextManagerRef.current) {
+        translationTextManagerRef.current.reset();
+        translationTextManagerRef.current = null;
+      }
+      if (streamBatcherRef.current) {
+        streamBatcherRef.current.reset();
+        streamBatcherRef.current = null;
+      }
+      if (translationTimeoutManagerRef.current) {
+        translationTimeoutManagerRef.current.destroy();
+        translationTimeoutManagerRef.current = null;
+      }
     };
   }, []);
 
@@ -360,210 +481,58 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
     return window.univoice?.generateCorrelationId?.() || `hook-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
   }, []);
 
-  // Translation timeout handling is now managed by useRealtimeTranscription hook
+  // å±¥æ­´ã«è¿½åŠ æ¸ˆã¿ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆIDã‚’è¿½è·¡
+  const addedToHistorySet = useRef<Set<string>>(new Set());
 
-  // Audio capture hook
-  const {
-    isCapturing,
-    error: audioCaptureError,
-    startCapture,
-    stopCapture,
-    audioMetrics
-  } = useAudioCapture({
-    enabled: isEnabled,
-    onError: (error) => {
-      console.error('[useUnifiedPipeline] Audio capture error:', error);
-      setError(error.message);
-      if (onError) {
-        onError(error.message);
-      }
+  // Handle translation timeout
+  const handleTranslationTimeout = useCallback((segmentId: string) => {
+    console.log('[useUnifiedPipeline] Handling translation timeout for segment:', segmentId);
+    
+    // Get segment data
+    const segment = segmentTranslationMap.current.get(segmentId);
+    if (!segment || !segment.original) {
+      console.warn('[useUnifiedPipeline] Timeout for unknown segment:', segmentId);
+      return;
     }
-  });
-
-  // Real-time transcription hook
-  const {
-    currentTranscription,
-    pendingSegments,
-    displayManager: transcriptionDisplayManager,
-    textManager: transcriptionTextManager,
-    handleASREvent,
-    clearTranscription,
-    resetManagers: resetTranscriptionManagers,
-    setDisplayPairsCallback,
-    clearTranslationTimeout
-  } = useRealtimeTranscription({
-    enabled: isEnabled,
-    onSegmentComplete: (segmentId, text) => {
-      console.log('[useUnifiedPipeline] Segment complete:', segmentId, text);
-      // Segment tracking is now handled by useTranslationQueue
-    },
-    onTranslationTimeout: (segmentId, originalText) => {
-      console.log('[useUnifiedPipeline] Translation timeout:', segmentId);
-      // Add to history with timeout status
-      if (!addedToHistorySetRef.current.has(segmentId)) {
-        addedToHistorySetRef.current.add(segmentId);
-        
-        const translation: Translation = {
-          id: segmentId,
-          original: originalText,
-          japanese: '[ç¿»è¨³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ]',
-          timestamp: Date.now(),
-          firstPaintMs: 0,
-          completeMs: 7000 // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“
-        };
-        
-        setHistory(prev => [...prev, translation]);
-        
-        // Add to flexible history grouper
-        if (historyGrouperRef.current && !addedToGrouperSetRef.current.has(segmentId)) {
-          historyGrouperRef.current.addSentence({
-            id: segmentId,
-            original: originalText,
-            translation: '[ç¿»è¨³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ]',
-            timestamp: Date.now()
-          });
-          addedToGrouperSetRef.current.add(segmentId);
-        }
-      }
-      
-      // Segment map cleanup is now handled by useTranslationQueue
-    },
-    onError: (error) => {
-      console.error('[useUnifiedPipeline] Transcription error:', error);
-      setError(error.message);
-      if (onError) {
-        onError(error.message);
-      }
+    
+    // Mark as timeout in displays
+    if (displayManagerRef.current) {
+      displayManagerRef.current.updateTranslation('[ç¿»è¨³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ]', segmentId);
+      displayManagerRef.current.completeTranslation(segmentId);
     }
-  });
-
-  // Connect display pairs callback from transcription hook
-  useEffect(() => {
-    setDisplayPairsCallback((pairs) => {
-      setDisplayPairs(pairs);
-    });
-  }, [setDisplayPairsCallback]);
-
-  // Update currentOriginal with transcription
-  useEffect(() => {
-    setCurrentOriginal(currentTranscription);
-  }, [currentTranscription]);
-
-  // Translation queue hook
-  const {
-    activeTranslations,
-    highQualityTranslations,
-    handleTranslationEvent,
-    clearTranslations,
-    resetBatcher,
-    registerSegmentMapping,
-    registerParagraphMapping,
-    getMappedId
-  } = useTranslationQueue({
-    enabled: isEnabled,
-    onTranslationComplete: (segmentId, translation, originalText) => {
-      console.log('[useUnifiedPipeline] Translation complete:', segmentId);
-      
-      // Clear translation timeout to prevent false timeout
-      const cleared = clearTranslationTimeout(segmentId);
-      if (cleared) {
-        console.log('[useUnifiedPipeline] Translation timeout cleared for:', segmentId);
-      }
-      
-      // Update display manager
-      if (transcriptionDisplayManager) {
-        transcriptionDisplayManager.completeTranslation(segmentId);
-      }
-
-      // Add to history
-      if (!addedToHistorySetRef.current.has(segmentId)) {
-        addedToHistorySetRef.current.add(segmentId);
-        
-        const translationObj: Translation = {
-          id: segmentId,
-          original: originalText,
-          japanese: translation,
-          timestamp: Date.now(),
-          firstPaintMs: 0,
-          completeMs: Date.now()
-        };
-        
-        setHistory(prev => {
-          const exists = prev.some(item => item.id === translationObj.id);
-          if (exists) {
-            console.log('[useUnifiedPipeline] Translation already in history, skipping:', translationObj.id);
-            return prev;
-          }
-          return [...prev, translationObj];
-        });
-        
-        if (onTranslation) {
-          onTranslation(translationObj);
-        }
-      }
-
-      // Segment map cleanup is now handled by useTranslationQueue
-    },
-    onHighQualityTranslation: (targetId, translationText, isParagraph) => {
-      console.log('[useUnifiedPipeline] High-quality translation received:', targetId, isParagraph);
+    
+    // Add to history with timeout status
+    if (!addedToHistorySet.current.has(segmentId)) {
+      addedToHistorySet.current.add(segmentId);
       
-      // Update in SessionMemory
-      if (isSessionActive && !isParagraph) {
-        try {
-          updateTranslation(targetId, {
-            japanese: translationText,
-            completeMs: Date.now()
-          });
-          console.log('[useUnifiedPipeline] Translation updated in session memory:', targetId);
-        } catch (error) {
-          console.error('[useUnifiedPipeline] Failed to update translation in session memory:', error);
-        }
-      }
+      const translation: Translation = {
+        id: segmentId,
+        original: segment.original,
+        japanese: '[ç¿»è¨³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ]',
+        timestamp: Date.now(),
+        firstPaintMs: 0,
+        completeMs: 7000 // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“
+      };
       
-      // Update FlexibleHistoryGrouper
-      if (historyGrouperRef.current) {
-        if (isParagraph) {
-          historyGrouperRef.current.updateParagraphTranslation(targetId, translationText);
-          console.log('[useUnifiedPipeline] Updated FlexibleHistoryGrouper paragraph translation:', targetId);
-        } else {
-          historyGrouperRef.current.updateSentenceTranslation(targetId, translationText);
-          console.log('[useUnifiedPipeline] Updated FlexibleHistoryGrouper sentence translation:', targetId);
-        }
-      }
+      setHistory(prev => [...prev, translation]);
       
-      // Update history blocks
-      setHistoryBlocks(prevBlocks => {
-        return prevBlocks.map(block => {
-          const updatedSentences = block.sentences.map(sentence => {
-            if (sentence.id === targetId) {
-              console.log('[useUnifiedPipeline] Updating sentence translation:', sentence.id);
-              return {
-                ...sentence,
-                translation: translationText
-              };
-            }
-            return sentence;
-          });
-          
-          const hasUpdates = updatedSentences.some((s, i) => s.translation !== block.sentences[i].translation);
-          if (hasUpdates) {
-            return {
-              ...block,
-              sentences: updatedSentences
-            };
-          }
-          return block;
+      // Add to flexible history grouper
+      if (historyGrouperRef.current && !addedToGrouperSet.current.has(segmentId)) {
+        historyGrouperRef.current.addSentence({
+          id: segmentId,
+          original: segment.original,
+          translation: '[ç¿»è¨³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ]',
+          timestamp: Date.now()
         });
-      });
-    },
-    onError: (error) => {
-      console.error('[useUnifiedPipeline] Translation queue error:', error);
-      setError(error.message);
-      if (onError) {
-        onError(error.message);
+        addedToGrouperSet.current.add(segmentId);
       }
     }
-  });
+    
+    // Clean up segment map
+    segmentTranslationMap.current.delete(segmentId);
+    
+    console.log('[useUnifiedPipeline] Translation timeout handled:', segmentId);
+  }, []);
 
   // Event handlers
   const handlePipelineEvent = useCallback((event: PipelineEvent) => {
@@ -573,47 +542,270 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
     // ASRã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’å¼·åŒ–
     if (event.type === 'asr') {
       console.log('[ASR DEBUG] Full event:', JSON.stringify(event, null, 2));
-      console.log('[ASR DEBUG] transcriptionDisplayManager exists:', !!transcriptionDisplayManager);
+      console.log('[ASR DEBUG] displayManagerRef exists:', !!displayManagerRef.current);
       console.log('[ASR DEBUG] displayPairs length:', displayPairs.length);
     }
 
     switch (event.type) {
       case 'asr':
-        // Delegate to real-time transcription hook
-        handleASREvent(event);
-        break;
-
-      case 'translation':
-        console.log('[useUnifiedPipeline] Translation event received:', {
-          segmentId: event.data.segmentId,
-          hasTranslation: !!event.data.translatedText,
+        console.log('[ASR] displayManagerRef.current:', !!displayManagerRef.current, 'segmentId:', event.data.segmentId);
+        console.log('[Display Debug] ASR Event:', {
+          text: event.data.text?.substring(0, 50) + '...',
           isFinal: event.data.isFinal,
-          textLength: event.data.translatedText?.length
+          currentOriginal: currentOriginal?.substring(0, 50) + '...'
         });
         
-        // Delegate to translation queue hook
-        handleTranslationEvent(event);
+        // Finalçµæœã®ç‰¹åˆ¥ãªãƒ­ã‚°
+        if (event.data.isFinal) {
+          console.log('[ASR FINAL] Final result received:', {
+            segmentId: event.data.segmentId,
+            textLength: event.data.text?.length,
+            text: event.data.text
+          });
+        }
         
-        // CRITICAL: Clear translation timeout immediately on any translation event
-        // This was the original behavior before refactoring
-        if (event.data.segmentId) {
-          const cleared = clearTranslationTimeout(event.data.segmentId);
-          if (cleared) {
-            console.log('[useUnifiedPipeline] Translation timeout cleared immediately for:', event.data.segmentId);
+        // Update display manager - now accepts interim results too
+        if (displayManagerRef.current) {
+          console.log('[ASR] Calling updateOriginal:', {
+            textLength: event.data.text?.length,
+            isFinal: event.data.isFinal,
+            segmentId: event.data.segmentId,
+            hasSegmentId: !!event.data.segmentId
+          });
+          displayManagerRef.current.updateOriginal(
+            event.data.text, 
+            event.data.isFinal, 
+            event.data.segmentId || `interim_${Date.now()}` // Provide segmentId even for interim
+          );
+          
+          // Track segment for translation pairing
+          if (event.data.isFinal) {
+            segmentTranslationMap.current.set(event.data.segmentId, {
+              original: event.data.text,
+              translation: ''
+            });
+            
+            // Start translation timeout
+            if (translationTimeoutManagerRef.current) {
+              translationTimeoutManagerRef.current.startTimeout(
+                event.data.segmentId,
+                event.data.text,
+                (timedOutSegmentId) => {
+                  console.log('[useUnifiedPipeline] Translation timeout for segment:', timedOutSegmentId);
+                  handleTranslationTimeout(timedOutSegmentId);
+                }
+              );
+            }
           }
+        } else {
+          console.warn('[ASR] Cannot update - displayManager:', !!displayManagerRef.current, 'segmentId:', event.data.segmentId);
+        }
+        
+        // Update current display (for compatibility)
+        if (originalTextManagerRef.current) {
+          console.log('[Display Debug] Updating currentOriginal:', event.data.text?.substring(0, 50) + '...', 'isFinal:', event.data.isFinal);
+          originalTextManagerRef.current.update(event.data.text);
         }
+        break;
+
+      case 'translation':
+        console.log('[useUnifiedPipeline] Translation event received:', event.data);
+        console.log('[useUnifiedPipeline] Translation text:', event.data.translatedText);
+        console.log('[useUnifiedPipeline] Translation text length:', event.data.translatedText?.length);
+        console.log('[useUnifiedPipeline] Translation text char codes (first 10):', 
+          event.data.translatedText ? [...event.data.translatedText.slice(0, 10)].map(c => c.charCodeAt(0)) : []);
         
-        // Update display with translation (handled by useRealtimeTranscription)
-        if (transcriptionDisplayManager && event.data.translatedText && event.data.segmentId) {
-          transcriptionDisplayManager.updateTranslation(
+        // å±¥æ­´ç”¨é«˜å“è³ªç¿»è¨³ã¾ãŸã¯ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç¿»è¨³ã®å ´åˆ
+        if (event.data.segmentId && 
+            (event.data.segmentId.startsWith('history_') || 
+             event.data.segmentId.startsWith('paragraph_'))) {
+          const isParagraph = event.data.segmentId.startsWith('paragraph_');
+          console.log(`[useUnifiedPipeline] ${isParagraph ? 'Paragraph' : 'History'} translation received:`, event.data.segmentId);
+          
+          // ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤ã—ã¦å…ƒã®IDã‚’å–å¾—
+          const baseId = event.data.segmentId.replace(/^(history_|paragraph_)/, '');
+          
+          // ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ã®å ´åˆã¯baseIdã‚’ãã®ã¾ã¾ä½¿ç”¨ã€å±¥æ­´ã®å ´åˆã¯ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ç¢ºèª
+          const targetId = isParagraph ? baseId : (segmentToCombinedMap.current.get(baseId) || baseId);
+          const translationText = event.data.translatedText || event.data.content;
+          
+          console.log(`[useUnifiedPipeline] Mapping ${isParagraph ? 'paragraph' : 'history'} translation:`, {
+            segmentId: event.data.segmentId,
+            baseId,
+            targetId,
+            isParagraph,
+            hasMapping: !isParagraph && segmentToCombinedMap.current.has(baseId)
+          });
+          
+          // é«˜å“è³ªç¿»è¨³ã‚’ä¿å­˜
+          if (translationText) {
+            highQualityTranslationsRef.current.set(targetId, translationText);
+            console.log('[useUnifiedPipeline] High-quality translation stored:', targetId, translationText.substring(0, 50));
+            
+            // SessionMemoryService: é«˜å“è³ªç¿»è¨³ã§æ›´æ–°
+            if (isSessionActive && !isParagraph) {
+              try {
+                updateTranslation(targetId, {
+                  japanese: translationText,
+                  completeMs: Date.now()
+                });
+                console.log('[useUnifiedPipeline] Translation updated in session memory:', targetId);
+              } catch (error) {
+                console.error('[useUnifiedPipeline] Failed to update translation in session memory:', error);
+              }
+            }
+            
+            // FlexibleHistoryGrouperã®å†…éƒ¨çŠ¶æ…‹ã‚‚æ›´æ–°
+            if (historyGrouperRef.current) {
+              if (isParagraph) {
+                // ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ã®å ´åˆ
+                historyGrouperRef.current.updateParagraphTranslation(targetId, translationText);
+                console.log('[useUnifiedPipeline] Updated FlexibleHistoryGrouper paragraph translation:', targetId);
+              } else {
+                // æ–‡ã®å ´åˆï¼ˆPhase 1ä¿®æ­£ï¼‰
+                historyGrouperRef.current.updateSentenceTranslation(targetId, translationText);
+                console.log('[useUnifiedPipeline] Updated FlexibleHistoryGrouper sentence translation:', targetId);
+              }
+            }
+            
+            // æ—¢å­˜ã®å±¥æ­´ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ›´æ–°
+            setHistoryBlocks(prevBlocks => {
+              return prevBlocks.map(block => {
+                // è©²å½“ã™ã‚‹ã‚»ãƒ³ãƒ†ãƒ³ã‚¹ã‚’å«ã‚€ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¢ã™
+                const updatedSentences = block.sentences.map(sentence => {
+                  if (sentence.id === targetId) {
+                    console.log('[useUnifiedPipeline] Updating sentence translation:', sentence.id);
+                    return {
+                      ...sentence,
+                      translation: translationText
+                    };
+                  }
+                  return sentence;
+                });
+                
+                // ã‚»ãƒ³ãƒ†ãƒ³ã‚¹ãŒæ›´æ–°ã•ã‚ŒãŸå ´åˆã€ãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ã‚’æ›´æ–°
+                const hasUpdates = updatedSentences.some((s, i) => s.translation !== block.sentences[i].translation);
+                if (hasUpdates) {
+                  return {
+                    ...block,
+                    sentences: updatedSentences
+                  };
+                }
+                return block;
+              });
+            });
+          }
+          
+          // é€šå¸¸ã®ç¿»è¨³å‡¦ç†ã¯ã‚¹ã‚­ãƒƒãƒ—
+          break;
+        }
+        
+        // Clear translation timeout if exists
+        if (event.data.segmentId && translationTimeoutManagerRef.current) {
+          translationTimeoutManagerRef.current.clearTimeout(event.data.segmentId);
+        }
+        
+        // Update display with translation
+        if (displayManagerRef.current && event.data.translatedText && event.data.segmentId) {
+          displayManagerRef.current.updateTranslation(
             event.data.translatedText,
             event.data.segmentId
           );
+          
+          // Update segment map
+          const segment = segmentTranslationMap.current.get(event.data.segmentId);
+          if (segment) {
+            segment.translation = event.data.translatedText;
+          }
+        }
+        
+        // Handle translation completion
+        if (event.data.isFinal && event.data.segmentId) {
+          // Mark translation as complete (starts 1.5s removal timer)
+          if (displayManagerRef.current) {
+            displayManagerRef.current.completeTranslation(event.data.segmentId);
+          }
+          
+          // ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç¿»è¨³ã®å ´åˆ
+          if (event.data.segmentId.startsWith('paragraph_')) {
+            const paragraphId = event.data.segmentId.replace('paragraph_', '');
+            const paragraphData = paragraphTranslationMap.current.get(paragraphId);
+            
+            if (paragraphData && historyGrouperRef.current) {
+              console.log('[DataFlow-12p] Updating paragraph translation:', {
+                paragraphId,
+                translationLength: event.data.translatedText.length
+              });
+              
+              // FlexibleHistoryGrouperã®ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç¿»è¨³ã‚’æ›´æ–°
+              historyGrouperRef.current.updateParagraphTranslation(
+                paragraphId,
+                event.data.translatedText
+              );
+              
+              // ãƒãƒƒãƒ—ã‚‚æ›´æ–°
+              paragraphData.translation = event.data.translatedText;
+            }
+            return; // ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç¿»è¨³ã®å ´åˆã¯ã“ã“ã§å‡¦ç†çµ‚äº†
+          }
+          
+          // Get complete segment data
+          const segment = segmentTranslationMap.current.get(event.data.segmentId);
+          if (segment && segment.original && segment.translation) {
+            // Add to FlexibleHistoryGrouper
+            // ğŸ”´ DISABLED: ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ãƒ¢ãƒ¼ãƒ‰å„ªå…ˆã®ãŸã‚ã€å€‹åˆ¥ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®å±¥æ­´è¿½åŠ ã‚’ç„¡åŠ¹åŒ–
+            // ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•å½¢æˆï¼ˆ20-60ç§’ï¼‰ã‚’å¾…ã¤ãŸã‚ã€ã“ã“ã§ã¯è¿½åŠ ã—ãªã„
+            /*
+            if (historyGrouperRef.current && !addedToGrouperSet.current.has(event.data.segmentId)) {
+              historyGrouperRef.current.addSentence({
+                id: event.data.segmentId,
+                original: segment.original,
+                translation: segment.translation,
+                timestamp: event.timestamp
+              });
+              addedToGrouperSet.current.add(event.data.segmentId);
+            }
+            */
+            
+            // Add to regular history (for backward compatibility)
+            if (!addedToHistorySet.current.has(event.data.segmentId)) {
+              addedToHistorySet.current.add(event.data.segmentId);
+              
+              const translation: Translation = {
+                id: event.data.segmentId,
+                original: event.data.originalText,
+                japanese: event.data.translatedText,
+                timestamp: event.timestamp,
+                firstPaintMs: 0,
+                completeMs: Date.now()
+              };
+              
+              setHistory(prev => {
+                const exists = prev.some(item => item.id === translation.id);
+                if (exists) {
+                  console.log('[useUnifiedPipeline] Translation already in history, skipping:', translation.id);
+                  return prev;
+                }
+                return [...prev, translation];
+              });
+              
+              if (onTranslation) {
+                onTranslation(translation);
+              }
+            }
+          }
+          
+          // Clean up segment map
+          segmentTranslationMap.current.delete(event.data.segmentId);
         }
         
         // Update current display for compatibility
-        if (event.data.translatedText) {
-          setCurrentTranslation(event.data.translatedText);
+        if (event.data.translatedText && translationTextManagerRef.current) {
+          console.log('[Display Debug] Updating currentTranslation (all events):', {
+            text: event.data.translatedText?.substring(0, 50) + '...',
+            isFinal: event.data.isFinal
+          });
+          translationTextManagerRef.current.update(event.data.translatedText);
         }
         break;
 
@@ -766,7 +958,13 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
           event.data.segmentIds.forEach((segmentId: string) => {
             console.log(`[DataFlow-12] Mapping segment ${segmentId} to combined ${event.data.combinedId}`);
             // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆIDã¨çµåˆIDã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä¿å­˜ï¼ˆå¾Œã§å±¥æ­´ç¿»è¨³ãŒæ¥ãŸæ™‚ã«ä½¿ç”¨ï¼‰
-            registerSegmentMapping(segmentId, event.data.combinedId);
+            segmentTranslationMap.current.set(segmentId, {
+              original: event.data.originalText,
+              translation: '',
+              combinedId: event.data.combinedId  // çµåˆIDã‚’è¿½åŠ 
+            });
+            // é€†å¼•ããƒãƒƒãƒ—ã‚‚ä¿å­˜ï¼ˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆIDã‹ã‚‰çµåˆIDã‚’æ¤œç´¢ï¼‰
+            segmentToCombinedMap.current.set(segmentId, event.data.combinedId);
           });
           
           // çµåˆã•ã‚ŒãŸæ–‡ã¨ã—ã¦å±¥æ­´ã«è¿½åŠ 
@@ -774,7 +972,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
           historyGrouperRef.current.addSentence({
             id: event.data.combinedId,
             original: event.data.originalText,
-            translation: '', // ç©ºæ–‡å­—åˆ—ã«å¤‰æ›´ï¼ˆPhase 1ä¿®æ­£ï¼‰
+            translation: 'ç¿»è¨³ä¸­...', // ç¿»è¨³å¾…ã¡ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼è¡¨ç¤º
             timestamp: event.data.timestamp
           });
           
@@ -877,7 +1075,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
       default:
         console.warn('[useUnifiedPipeline] Unknown event type:', event);
     }
-  }, [onError, onStatusChange, onTranslation, onSummary, isSessionActive, addTranslation, updateTranslation, addSummary, registerSegmentMapping, registerParagraphMapping, handleTranslationEvent, handleASREvent, transcriptionDisplayManager]);
+  }, [onError, onStatusChange, onTranslation, onSummary, isSessionActive, addTranslation, updateTranslation, addSummary]);
 
   // handlePipelineEventã¸ã®æœ€æ–°ã®å‚ç…§ã‚’ä¿æŒ
   const handlePipelineEventRef = useRef(handlePipelineEvent);
@@ -904,7 +1102,9 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
       // æ–‡å­—èµ·ã“ã—çµæœã®ç›´æ¥æ›´æ–°
       const originalUpdateHandler = (_event: any, data: any) => {
         console.log('[useUnifiedPipeline] current-original-update received:', data);
-        // Original text is now managed through transcription hook
+        if (originalTextManagerRef.current) {
+          originalTextManagerRef.current.update(data.text);
+        }
         setCurrentOriginal(data.text);
       };
       window.electron.on('current-original-update', originalUpdateHandler);
@@ -936,7 +1136,8 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
             timeRange: {
               start: summary.data.startTime || 0,
               end: summary.data.endTime || Date.now()
-            }
+            },
+            threshold: summary.data.threshold // Add threshold for progressive summaries
           };
           
           setSummaries(prev => {
@@ -997,7 +1198,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
       // SessionMemoryService: ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹
       // classNameãŒãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨
       const sessionClassName = className || `session_${new Date().toISOString().split('T')[0]}`;
-      if (!isSessionActive && currentSourceLanguage && currentTargetLanguage) {
+      if (!isSessionActive) {
         console.log('[useUnifiedPipeline] Starting new session:', sessionClassName);
         try {
           await startSession(sessionClassName, currentSourceLanguage, currentTargetLanguage);
@@ -1007,11 +1208,6 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
         }
       }
 
-      // Validate language settings
-      if (!currentSourceLanguage || !currentTargetLanguage) {
-        throw new Error('Language settings are required. Please configure them in Setup.');
-      }
-
       const result = await window.univoice?.startListening?.({
         sourceLanguage: currentSourceLanguage,
         targetLanguage: currentTargetLanguage,
@@ -1021,7 +1217,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
         throw new Error(result?.error || 'Failed to start pipeline');
       }
 
-      await startCapture(); // æˆåŠŸã—ãŸã‚‰éŸ³å£°ã‚­ãƒ£ãƒ—ãƒãƒ£é–‹å§‹
+      await startAudioCapture(); // æˆåŠŸã—ãŸã‚‰éŸ³å£°ã‚­ãƒ£ãƒ—ãƒãƒ£é–‹å§‹
 
       setIsRunning(true);
       setState(prev => ({ ...prev, status: 'listening', startTime: Date.now() }));
@@ -1037,7 +1233,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
         onError(msg);
       }
     }
-  }, [currentSourceLanguage, currentTargetLanguage, state.status, generateCorrelationId, onError, className, isSessionActive, startSession, startCapture]);
+  }, [currentSourceLanguage, currentTargetLanguage, state.status, generateCorrelationId, onError, className, isSessionActive, startSession]);
 
   const stop = useCallback(async () => {
     // ãƒ¬ãƒ¼ã‚¹é˜²æ­¢
@@ -1055,7 +1251,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
         if (!result?.success) console.warn('[useUnifiedPipeline] Stop warning:', result?.error);
       }
 
-      stopCapture();
+      stopAudioCapture();
 
       // SessionMemoryService: ã‚»ãƒƒã‚·ãƒ§ãƒ³å®Œäº†
       if (isSessionActive) {
@@ -1081,7 +1277,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
         onError(errorMsg);
       }
     }
-  }, [state.status, onError, isSessionActive, completeSession, stopCapture]);
+  }, [state.status, onError, isSessionActive, completeSession]);
 
   const translateUserInput = useCallback(async (text: string, from: string = 'ja', to: string = 'en'): Promise<string> => {
     try {
@@ -1111,6 +1307,126 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
     }
   }, [onError]);
 
+  // Audio capture functions
+  const audioContextRef = useRef<AudioContext | null>(null);
+  const mediaStreamRef = useRef<MediaStream | null>(null);
+  const processorRef = useRef<IAudioProcessor | null>(null);
+
+  const startAudioCapture = useCallback(async () => {
+    // æ—¢ã«é–‹å§‹æ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
+    if (audioContextRef.current || mediaStreamRef.current) {
+      console.warn('[useUnifiedPipeline] Audio capture already started');
+      return;
+    }
+
+    try {
+      const stream = await navigator.mediaDevices.getUserMedia({
+        audio: {
+          channelCount: 1,
+          sampleRate: 16000,           // å¸Œæœ›å€¤ï¼ˆå®Ÿéš›ã¯ç„¡è¦–ã•ã‚Œã‚‹ã“ã¨æœ‰ï¼‰
+          echoCancellation: true,
+          noiseSuppression: true,
+          autoGainControl: false
+        }
+      });
+      mediaStreamRef.current = stream;
+
+      // WebAudio åˆæœŸåŒ–
+      const ctx = new AudioContext({ sampleRate: 16000 });
+      audioContextRef.current = ctx;
+
+      const source = ctx.createMediaStreamSource(stream);
+
+      // Create AudioWorkletProcessor with type safety
+      let audioProcessCount = 0;
+      
+      const processor = await AudioWorkletProcessor.create(
+        ctx,
+        source,
+        (event: MessageEvent<AudioProcessorMessage>) => {
+          const { type, data } = event.data;
+
+          switch (type) {
+            case 'initialized':
+              console.log('[useUnifiedPipeline] AudioWorklet initialized:', data);
+              break;
+
+            case 'audio':
+              // PCM16ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡
+              const pcm16 = new Int16Array(data.pcm16);
+              
+              audioProcessCount++;
+              if (audioProcessCount % 50 === 1) {
+                console.log('[useUnifiedPipeline] Audio processing:', {
+                  frameCount: audioProcessCount,
+                  pcm16Length: pcm16.length,
+                  sampleRate: data.sampleRate,
+                  timestamp: data.timestamp,
+                  hasElectronAPI: !!window.electron,
+                  hasSendAudioChunk: !!window.electron?.sendAudioChunk
+                });
+              }
+          
+              if (window.electron?.sendAudioChunk) {
+                window.electron.sendAudioChunk(pcm16);
+                
+                if (audioProcessCount % 50 === 1) {
+                  console.log('[useUnifiedPipeline] Sending audio chunk to main process');
+                }
+              } else {
+                if (audioProcessCount % 50 === 1) {
+                  console.error('[useUnifiedPipeline] Cannot send audio - electron API not available');
+                }
+              }
+              break;
+
+            case 'error':
+              console.error('[useUnifiedPipeline] AudioWorklet error:', data);
+              break;
+          }
+        },
+        {
+          targetSampleRate: 16000,
+          bufferSize: 512,
+          debug: false
+        }
+      );
+      
+      processorRef.current = processor;
+      console.log('[useUnifiedPipeline] Audio capture started. ctx.sampleRate=', ctx.sampleRate);
+    } catch (err) {
+      console.error('[useUnifiedPipeline] Audio capture failed:', err);
+      throw err;
+    }
+  }, []);
+
+  const stopAudioCapture = useCallback(() => {
+    try {
+      console.log('[useUnifiedPipeline] Stopping audio capture...');
+      
+      if (processorRef.current) {
+        // Use the type-safe destroy method
+        processorRef.current.destroy();
+        processorRef.current = null;
+      }
+      
+      if (audioContextRef.current) {
+        audioContextRef.current.close();
+        audioContextRef.current = null;
+      }
+      
+      if (mediaStreamRef.current) {
+        mediaStreamRef.current.getTracks().forEach(track => track.stop());
+        mediaStreamRef.current = null;
+      }
+      
+      console.log('[useUnifiedPipeline] Audio capture stopped');
+      
+    } catch (err: any) {
+      console.error('[useUnifiedPipeline] Audio capture stop failed:', err);
+    }
+  }, []);
+
   // Clear functions
   const clearHistory = useCallback(() => {
     setHistory([]);
@@ -1137,19 +1453,21 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
       setCurrentOriginal('');
       setCurrentTranslation('');
       setDisplayPairs([]);
-      clearTranslations(); // Clear translation queue data
-      addedToHistorySetRef.current.clear(); // å±¥æ­´è¿½åŠ æ¸ˆã¿ã‚»ãƒƒãƒˆã‚‚ã‚¯ãƒªã‚¢
-      addedToGrouperSetRef.current.clear(); // ã‚°ãƒ«ãƒ¼ãƒ‘ãƒ¼è¿½åŠ æ¸ˆã¿ã‚»ãƒƒãƒˆã‚‚ã‚¯ãƒªã‚¢
+      segmentTranslationMap.current.clear();
+      addedToHistorySet.current.clear(); // å±¥æ­´è¿½åŠ æ¸ˆã¿ã‚»ãƒƒãƒˆã‚‚ã‚¯ãƒªã‚¢
+      addedToGrouperSet.current.clear(); // ã‚°ãƒ«ãƒ¼ãƒ‘ãƒ¼è¿½åŠ æ¸ˆã¿ã‚»ãƒƒãƒˆã‚‚ã‚¯ãƒªã‚¢
       
       // Reset managers
-      resetTranscriptionManagers(); // Reset transcription-related managers
+      if (displayManagerRef.current) {
+        displayManagerRef.current.reset();
+      }
       if (historyGrouperRef.current) {
         historyGrouperRef.current.reset();
       }
     } catch (err: any) {
       console.error('[useUnifiedPipeline] Clear all failed:', err);
     }
-  }, [clearHistory, clearSummaries, clearError, resetTranscriptionManagers, clearTranslations]);
+  }, [clearHistory, clearSummaries, clearError]);
 
   // Generate vocabulary from current session
   const generateVocabulary = useCallback(async () => {
@@ -1220,7 +1538,7 @@ export const useUnifiedPipeline = (options: UseUnifiedPipelineOptions = {}) => {
     currentOriginal,
     currentTranslation,
     displayPairs,
-    threeLineDisplay,
+    threeLineDisplay: RealtimeDisplayPresenter.createThreeLineDisplay(displayPairs),
     historyBlocks,
     groupedHistory: (() => {
       // Convert history to 3-item groups for legacy compatibility
