# 履歴更新実装計画 - シニアエンジニア視点での完全実装

## 実装概要

文単位履歴管理システムを完成させ、リアルタイム翻訳と高品質翻訳の二段階システムを実装します。

## 現状の問題点

1. **SentenceCombinerの未接続**
   - クラスは存在するが、実際にセグメントが渡されていない
   - コールバック関数が存在しないメソッドを参照

2. **翻訳パイプラインの不完全**
   - history_プレフィックス付き翻訳の処理が未実装
   - 優先度制御が活用されていない

3. **フロントエンドの未対応**
   - FlexibleHistoryGrouperが使用されていない
   - 高品質翻訳の更新処理が存在しない

## 実装ステップ

### Phase 1: バックエンド完成（2-3時間）

#### 1.1 UnifiedPipelineServiceの修正
```typescript
// 追加が必要なメソッド

private async handleCombinedSentence(combinedSentence: CombinedSentence): Promise<void> {
  // 1. 結合されたセンテンスのログ出力
  // 2. 既存の翻訳を収集（segmentIdsから）
  // 3. 高品質翻訳用のキューイング（低優先度）
  // 4. history_プレフィックス付きでキューに追加
}

private async executeHistoryTranslation(queuedTranslation: QueuedTranslation): Promise<TranslationResult> {
  // 1. 通常のexecuteTranslationと同様の処理
  // 2. モデルをgpt-5-miniに変更
  // 3. より詳細なプロンプト使用
  // 4. 結果にhistory_プレフィックスを維持
}
```

#### 1.2 processTranscriptSegmentの修正
- 現在: セグメントを直接翻訳キューに追加
- 修正後: SentenceCombinerにもセグメントを渡す

### Phase 2: フロントエンド統合（2-3時間）

#### 2.1 useUnifiedPipelineの修正
```typescript
// 必要な追加処理

1. FlexibleHistoryGrouperのインスタンス作成
2. history_プレフィックス翻訳の処理
3. historyBlocksの状態管理
4. 高品質翻訳によるブロック更新
```

#### 2.2 HistorySectionの改善
- 高品質翻訳の視覚的表示
- 更新アニメーション
- リアルタイム翻訳との差分表示（オプション）

### Phase 3: テストと検証（1-2時間）

#### 3.1 統合テスト
- 文単位結合の動作確認
- 二段階翻訳の確認
- 履歴更新の確認

#### 3.2 パフォーマンステスト
- リアルタイム翻訳への影響確認
- メモリ使用量の監視
- キュー圧迫時の挙動確認

## リスク分析と対策

### リスク1: リアルタイム翻訳への影響
**影響度**: 高
**発生確率**: 中
**対策**:
- TranslationQueueManagerの優先度制御を厳密に実装
- 履歴翻訳は必ず低優先度で実行
- キュー圧迫時は履歴翻訳をスキップ

### リスク2: メモリ使用量の増加
**影響度**: 中
**発生確率**: 高
**対策**:
- SentenceCombinerのバッファサイズ制限（最大10セグメント）
- 古い履歴データの定期的なクリーンアップ
- WeakMapを使用した翻訳キャッシュ

### リスク3: 複雑性の増加
**影響度**: 中
**発生確率**: 高
**対策**:
- 明確な責任分離（SentenceCombiner、TranslationQueue、HistoryGrouper）
- 詳細なログ出力とデバッグモード
- 段階的なロールアウト（フィーチャーフラグ）

## 実装の優先順位

1. **必須（P0）** - 基本機能の完成
   - handleCombinedSentenceの実装
   - executeHistoryTranslationの実装
   - processTranscriptSegmentの修正

2. **重要（P1）** - ユーザー体験の向上
   - FlexibleHistoryGrouperの統合
   - 履歴UIの更新処理
   - 基本的なテスト

3. **推奨（P2）** - 品質と保守性
   - パフォーマンス最適化
   - エラーハンドリングの強化
   - 包括的なテストスイート

## 成功基準

1. **機能面**
   - 2-3文が自動的に結合される
   - 高品質翻訳が履歴に反映される
   - リアルタイム翻訳に影響がない

2. **パフォーマンス面**
   - リアルタイム翻訳の遅延増加 < 50ms
   - メモリ使用量の増加 < 100MB
   - CPU使用率の増加 < 10%

3. **品質面**
   - 単体テストカバレッジ > 80%
   - 統合テスト全項目合格
   - エラーレート < 1%

## タイムライン

- **Day 1（4時間）**: バックエンド実装とフロントエンド基本統合
- **Day 2（2時間）**: UI改善とテスト
- **Day 3（1時間）**: 最終調整とドキュメント更新

## 注意事項

1. **既存機能への影響を最小化**
   - 全ての変更は後方互換性を維持
   - フィーチャーフラグで段階的に有効化

2. **ドキュメントの同時更新**
   - 実装と同時にドキュメントを更新
   - 虚偽の記載を修正

3. **コードレビューの重要性**
   - 各フェーズごとに自己レビュー
   - テスト結果を必ず確認

## まとめ

この実装により、ユーザーは以下の恩恵を受けます：
- 履歴が読みやすい文単位で表示
- 高品質な翻訳が自動的に適用
- リアルタイム性能は維持

実装は段階的に進め、各ステップで動作確認を行います。