/**
 * UnifiedPipelineService - Pure Domain Service
 * 
 * Responsibilities:
 * - Manage ASR and Translation pipeline
 * - Integrate with StreamCoalescer for UI optimization
 * - Emit domain events (no UI dependencies)
 * - Handle error recovery and state management
 * 
 * Key Changes from Original:
 * - Removed all UI-specific code
 * - Integrated StreamCoalescer for segment management
 * - Pure event emission (no direct UI updates)
 * - Enhanced error handling and recovery
 */

import { EventEmitter } from 'events';
import { DeepgramStreamAdapter, TranscriptResult, DeepgramError } from '../adapters/DeepgramStreamAdapter';
import OpenAI from 'openai';
// üî¥ CRITICAL: SegmentManager„ÅÆ„Ç§„É≥„Éù„Éº„Éà„ÇíÂâäÈô§Ôºà‰ΩøÁî®„Åó„Å™„ÅÑÔºâ
// import { SegmentManager } from './SegmentManager';
import { AdvancedFeatureService } from './AdvancedFeatureService';
import { 
  createASREvent,
  createTranslationEvent,
  createErrorEvent,
  createStatusEvent,
  createVocabularyEvent,
  createFinalReportEvent,
  PipelineEvent
} from '../ipc/contracts';
import { LanguageConfig, LanguageCode, getTranslationPrompt } from './LanguageConfig';
import { logger } from '../../utils/logger';
import { TranslationQueueManager, QueuedTranslation } from './TranslationQueueManager';
import { SentenceCombiner, CombinedSentence } from './SentenceCombiner';
// Shadow ModeÁµ±ÂêàÁî®„ÅÆ„Ç§„É≥„Éù„Éº„ÉàÔºàüî¥ Êó¢Â≠òÂÆüË£Ö„ÅØÂ§âÊõ¥„Åó„Å™„ÅÑÔºâ
import { LLMGateway, LLMPurpose, LLMConfig } from '../../infrastructure/llm/types';
import { OpenAIGateway } from '../../infrastructure/llm/OpenAIGateway';

// ===== Configuration Interfaces =====
interface AudioConfig {
  frameMs: number;
  frameSize: number;
  sampleRate: number;
}

interface DeepgramConfig {
  apiKey: string;
  model: string;
  interim: boolean;
  endpointing: number;
  utteranceEndMs: number;
  smartFormat?: boolean; // NEW: Smart formatting (includes punctuation)
  noDelay?: boolean;     // NEW: Skip 3-second finalization delay
}

interface OpenAIConfig {
  apiKey: string;
  models: {
    translate: string;
    summary: string;
    summaryTranslate: string;
    userTranslate: string;
    vocabulary: string;
    report: string;
  };
  maxTokens: {
    translate: number;
    summary: number;
    vocabulary: number;
    report: number;
  };
}

// ===== Domain Models =====
interface TranscriptSegment {
  id: string;
  text: string;
  timestamp: number;
  confidence: number;
  isFinal: boolean;
  startMs?: number;
  endMs?: number;
}

interface Translation {
  id: string;
  original: string;
  translated: string;
  sourceLanguage: string;
  targetLanguage: string;
  timestamp: number;
  confidence: number;
  isFinal: boolean;
}

interface Summary {
  id: string;
  english: string;
  japanese: string;
  wordCount: number;
  timestamp: number;
  timeRange: {
    start: number;
    end: number;
  };
}

// ===== Pipeline States =====
type PipelineState = 'idle' | 'starting' | 'listening' | 'processing' | 'stopping' | 'error';

export class UnifiedPipelineService extends EventEmitter {
  // Configuration
  private audioConfig: AudioConfig;
  private deepgramConfig: DeepgramConfig;
  private openaiConfig: OpenAIConfig;
  
  // External services
  private deepgramAdapter: DeepgramStreamAdapter | null = null;
  private openai: OpenAI;
  // üî¥ CRITICAL: SegmentManager„Éï„Ç£„Éº„É´„Éâ„ÇíÂâäÈô§Ôºà‰ΩøÁî®„Åó„Å™„ÅÑÔºâ
  // private segmentManager: SegmentManager;
  private advancedFeatures: AdvancedFeatureService;
  private translationQueue: TranslationQueueManager;
  private sentenceCombiner: SentenceCombiner;
  
  // Shadow ModeÁî®„ÅÆLLM GatewayÔºàüî¥ Êó¢Â≠òÂÆüË£Ö„Å´ÂΩ±Èüø„Åó„Å™„ÅÑÔºâ
  private llmGateway: LLMGateway | null = null;
  private enableShadowMode: boolean = false;
  
  // State management
  private state: PipelineState = 'idle';
  private currentCorrelationId: string | null = null;
  private sourceLanguage: LanguageCode;
  private targetLanguage: LanguageCode;
  
  // Data storage
  private transcriptSegments: TranscriptSegment[] = [];
  private translations: Translation[] = [];
  private summaries: Summary[] = [];
  
  // Performance tracking
  private startTime: number = 0;
  private lastActivityTime: number = 0;
  
  private componentLogger = logger.child('UnifiedPipelineService');

  constructor(
    audioConfig: AudioConfig,
    deepgramConfig: DeepgramConfig,
    openaiConfig: OpenAIConfig,
    languageConfig: LanguageConfig = { sourceLanguage: 'en', targetLanguage: 'ja' }
  ) {
    super();
    
    this.audioConfig = audioConfig;
    this.deepgramConfig = deepgramConfig;
    this.openaiConfig = openaiConfig;
    this.sourceLanguage = languageConfig.sourceLanguage;
    this.targetLanguage = languageConfig.targetLanguage;
    
    // Initialize OpenAI client
    this.openai = new OpenAI({
      apiKey: this.openaiConfig.apiKey,
    });
    
    // üî¥ CRITICAL: SegmentManager„ÅÆÂàùÊúüÂåñ„ÇíÂÆåÂÖ®„Å´ÂâäÈô§
    // ÈáçË§á„ÅÆÂéüÂõ†ÔºöSegmentManager„ÅØÁøªË®≥„ÇíÈáçË§á„Åß„Éà„É™„Ç¨„Éº„Åó„Å¶„ÅÑ„Åü
    // Ë¶™„Éï„Ç©„É´„ÉÄÔºàUniVoice 1.0Ôºâ„Å´„ÅØ„Åì„ÅÆÊ©üËÉΩ„ÅØÂ≠òÂú®„Åó„Å™„ÅÑ
    
    // Initialize TranslationQueueManager
    this.translationQueue = new TranslationQueueManager({
      maxConcurrency: parseInt(process.env.TRANSLATION_MAX_CONCURRENCY || '3'),
      maxQueueSize: parseInt(process.env.TRANSLATION_MAX_QUEUE_SIZE || '100'),
      requestTimeoutMs: parseInt(process.env.TRANSLATION_TIMEOUT_MS || '30000')
    });
    
    // Set translation handler
    this.translationQueue.setTranslationHandler(async (queuedTranslation: QueuedTranslation) => {
      // Â±•Ê≠¥Áî®ÁøªË®≥„ÅãÈÄöÂ∏∏ÁøªË®≥„Åã„ÅßÂàÜÂ≤ê
      if (queuedTranslation.segmentId.startsWith('history_')) {
        return this.executeHistoryTranslation(queuedTranslation);
      } else {
        return this.executeTranslation(queuedTranslation);
      }
    });
    
    // Initialize SentenceCombiner
    this.sentenceCombiner = new SentenceCombiner(
      (combinedSentence) => this.handleCombinedSentence(combinedSentence),
      {
        maxSegments: 10,
        timeoutMs: 2000,
        minSegments: 2
      }
    );
    
    // Initialize AdvancedFeatureService
    this.advancedFeatures = new AdvancedFeatureService({
      openaiApiKey: this.openaiConfig.apiKey,
      summaryInterval: parseInt(process.env.SUMMARY_INTERVAL_MS || '600000'),
      summaryModel: process.env.OPENAI_MODEL_SUMMARY || 'gpt-5-mini',
      vocabularyModel: process.env.OPENAI_MODEL_VOCABULARY || 'gpt-5-mini',
      reportModel: process.env.OPENAI_MODEL_REPORT || 'gpt-5',
      maxTokens: {
        summary: parseInt(process.env.OPENAI_SUMMARY_MAX_TOKENS || '1500'),
        vocabulary: parseInt(process.env.OPENAI_VOCAB_MAX_TOKENS || '1500'),
        report: parseInt(process.env.OPENAI_REPORT_MAX_TOKENS || '8192')
      }
    });
    
    // Forward advanced feature events
    this.advancedFeatures.on('summaryGenerated', (event) => {
      this.emit('pipelineEvent', event);
    });
    
    this.advancedFeatures.on('error', (event) => {
      this.emit('pipelineEvent', event);
    });
    
    this.componentLogger.info('UnifiedPipelineService initialized', {
      audioConfig: this.audioConfig,
      deepgramModel: this.deepgramConfig.model,
      openaiModels: this.openaiConfig.models,
    });
    
    // Shadow Mode„ÅÆÂàùÊúüÂåñÔºàüî¥ Áí∞Â¢ÉÂ§âÊï∞„ÅßÊúâÂäπÂåñÔºâ
    this.enableShadowMode = process.env.ENABLE_LLM_SHADOW_MODE === 'true';
    if (this.enableShadowMode) {
      try {
        // LLM GatewayË®≠ÂÆö„ÇíÊßãÁØâÔºàÊó¢Â≠ò„ÅÆOpenAIË®≠ÂÆö„ÇíÊµÅÁî®Ôºâ
        const llmConfig: LLMConfig = {
          apiKey: this.openaiConfig.apiKey,
          models: {
            [LLMPurpose.TRANSLATION]: this.openaiConfig.models.translate,
            [LLMPurpose.SUMMARY]: this.openaiConfig.models.summary,
            [LLMPurpose.SUMMARY_TRANSLATE]: this.openaiConfig.models.summaryTranslate || this.openaiConfig.models.translate,
            [LLMPurpose.USER_TRANSLATE]: this.openaiConfig.models.userTranslate || this.openaiConfig.models.translate,
            [LLMPurpose.VOCABULARY]: this.openaiConfig.models.vocabulary,
            [LLMPurpose.REPORT]: this.openaiConfig.models.report
          },
          maxTokens: {
            [LLMPurpose.TRANSLATION]: this.openaiConfig.maxTokens.translate,
            [LLMPurpose.SUMMARY]: this.openaiConfig.maxTokens.summary,
            [LLMPurpose.SUMMARY_TRANSLATE]: this.openaiConfig.maxTokens.translate,
            [LLMPurpose.USER_TRANSLATE]: this.openaiConfig.maxTokens.translate,
            [LLMPurpose.VOCABULARY]: this.openaiConfig.maxTokens.vocabulary,
            [LLMPurpose.REPORT]: this.openaiConfig.maxTokens.report
          }
        };
        
        this.llmGateway = new OpenAIGateway(llmConfig);
        this.componentLogger.info('Shadow Mode enabled with LLM Gateway');
      } catch (error) {
        this.componentLogger.error('Failed to initialize LLM Gateway for Shadow Mode', { error });
        this.enableShadowMode = false; // Shadow Mode„ÇíÁÑ°ÂäπÂåñ
      }
    }
  }

  /**
   * Start listening with specified languages
   */
  async startListening(
    sourceLanguage: LanguageCode = 'en',
    targetLanguage: LanguageCode = 'ja',
    correlationId: string
  ): Promise<void> {
    if (this.state !== 'idle') {
      throw new Error(`Cannot start listening in state: ${this.state}`);
    }
    
    this.setState('starting');
    this.currentCorrelationId = correlationId;
    this.sourceLanguage = sourceLanguage;
    this.targetLanguage = targetLanguage;
    this.startTime = Date.now();
    
    try {
      await this.connectToDeepgram();
      this.setState('listening');
      
      // Start advanced features for periodic summaries with language settings
      this.advancedFeatures.start(correlationId, this.sourceLanguage, this.targetLanguage);
      
      this.componentLogger.info('Started listening', {
        sourceLanguage,
        targetLanguage,
        correlationId,
      });
      
    } catch (error) {
      this.setState('error');
      this.emitError('DEEPGRAM_CONNECTION_FAILED', 
        error instanceof Error ? error.message : 'Failed to connect to Deepgram',
        correlationId
      );
      throw error;
    }
  }

  /**
   * Stop listening
   */
  async stopListening(correlationId: string): Promise<void> {
    if (this.state === 'idle') {
      return; // Already stopped
    }
    
    this.setState('stopping');
    
    try {
      // üî¥ CRITICAL: SegmentManager.forceEmitAll()„ÇíÂâäÈô§
      // Ë¶™„Éï„Ç©„É´„ÉÄÔºàUniVoice 1.0Ôºâ„Å®Âêå„Åò„Ç∑„É≥„Éó„É´„Å™ÂÆüË£Ö
      // this.segmentManager.forceEmitAll();
      
      // Force emit any remaining segments in SentenceCombiner
      this.sentenceCombiner.forceEmit();
      
      // Stop advanced features
      await this.advancedFeatures.stop();
      
      // Close Deepgram connection
      if (this.deepgramAdapter) {
        this.deepgramAdapter.disconnect();
        this.deepgramAdapter.destroy();
        this.deepgramAdapter = null;
      }
      
      this.setState('idle');
      this.currentCorrelationId = null;
      
      this.componentLogger.info('Stopped listening', {
        correlationId,
        duration: Date.now() - this.startTime,
        segmentsProcessed: this.transcriptSegments.length,
        translationsGenerated: this.translations.length,
      });
      
    } catch (error) {
      this.setState('error');
      this.emitError('STOP_FAILED',
        error instanceof Error ? error.message : 'Failed to stop listening',
        correlationId
      );
      throw error;
    }
  }

  /**
   * Get current state
   */
  getState(): {
    state: PipelineState;
    sourceLanguage: string;
    targetLanguage: string;
    segmentCount: number;
    translationCount: number;
    summaryCount: number;
    uptime: number;
  } {
    return {
      state: this.state,
      sourceLanguage: this.sourceLanguage,
      targetLanguage: this.targetLanguage,
      segmentCount: this.transcriptSegments.length,
      translationCount: this.translations.length,
      summaryCount: this.summaries.length,
      uptime: this.startTime > 0 ? Date.now() - this.startTime : 0,
    };
  }

  /**
   * Send audio chunk for processing
   */
  sendAudioChunk(buffer: Buffer): void {
    if (this.state !== 'listening' || !this.deepgramAdapter) {
      return;
    }
    
    try {
      this.deepgramAdapter.sendAudio(buffer);
      this.lastActivityTime = Date.now();
    } catch (error) {
      this.componentLogger.error('Failed to send audio chunk', {
        error: error instanceof Error ? error.message : String(error),
        bufferSize: buffer.length,
      });
    }
  }

  /**
   * Clear all history
   */
  clearHistory(): void {
    this.transcriptSegments = [];
    this.translations = [];
    this.summaries = [];
    // üî¥ CRITICAL: SegmentManager.resetAll()„ÇíÂâäÈô§
    // this.segmentManager.resetAll();
    
    this.componentLogger.info('History cleared');
  }

  /**
   * Get metrics
   */
  getMetrics() {
    return {
      pipeline: this.getState(),
      // üî¥ CRITICAL: SegmentManager.getMetrics()„ÇíÂâäÈô§
      // segmentManager: this.segmentManager.getMetrics(),
      performance: {
        startTime: this.startTime,
        lastActivity: this.lastActivityTime,
        uptime: this.startTime > 0 ? Date.now() - this.startTime : 0,
      },
    };
  }

  // ===== Private Methods =====

  // üî¥ CRITICAL: SegmentManager„ÅÆ„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÇíÁÑ°ÂäπÂåñ
  // ÈáçË§á„ÅÆÂéüÂõ†Ôºö„Åì„ÅÆ„Éè„É≥„Éâ„É©„ÇÇÁøªË®≥„Çí„Éà„É™„Ç¨„Éº„Åó„Å¶„ÅÑ„Åü
  // Ë¶™„Éï„Ç©„É´„ÉÄÔºàUniVoice 1.0Ôºâ„Å´„ÅØ„Åì„ÅÆÊ©üËÉΩ„ÅØÂ≠òÂú®„Åó„Å™„ÅÑ
  /*
  private setupSegmentManager(): void {
    this.segmentManager.on('coalescedSegment', (coalescedSegment) => {
      // Emit segment event
      this.emitEvent(createSegmentEvent({
        segmentId: coalescedSegment.segmentId,
        text: coalescedSegment.data.text,
        translation: coalescedSegment.data.translation,
        status: coalescedSegment.data.isFinal ? 'completed' : 'processing',
        metadata: {
          confidence: coalescedSegment.data.confidence,
          holdDuration: coalescedSegment.holdDuration,
          timestamp: coalescedSegment.timestamp,
        },
      }, this.currentCorrelationId || 'unknown'));
      
      // Trigger translation if needed
      if (coalescedSegment.data.text && !coalescedSegment.data.translation) {
        this.translateSegment(coalescedSegment.data.text, coalescedSegment.segmentId);
      }
    });
  }
  */

  /**
   * Connect to Deepgram using DeepgramStreamAdapter
   * Clean Architecture: WebSocketÁÆ°ÁêÜ„Çí„Ç¢„ÉÄ„Éó„Çø„ÉºÂ±§„Å´ÂßîË≠≤
   */
  private async connectToDeepgram(): Promise<void> {
    // DeepgramStreamAdapter „ÅÆË®≠ÂÆö„ÇíÊßãÁØâ
    const adapterConfig = {
      apiKey: this.deepgramConfig.apiKey,
      model: this.deepgramConfig.model,
      interim: this.deepgramConfig.interim,
      endpointing: this.deepgramConfig.endpointing,
      utteranceEndMs: this.deepgramConfig.utteranceEndMs,
      smartFormat: this.deepgramConfig.smartFormat,
      noDelay: this.deepgramConfig.noDelay,
      sampleRate: this.audioConfig.sampleRate,
      sourceLanguage: this.sourceLanguage
    };
    
    this.componentLogger.info('Creating DeepgramStreamAdapter', { 
      config: { ...adapterConfig, apiKey: '***' } 
    });
    
    // „Ç¢„ÉÄ„Éó„Çø„Éº„Çí‰ΩúÊàê
    this.deepgramAdapter = new DeepgramStreamAdapter(adapterConfig);
    
    // „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº„ÇíË®≠ÂÆö
    this.setupDeepgramEventHandlers();
    
    // Êé•Á∂ö
    try {
      await this.deepgramAdapter.connect();
      this.componentLogger.info('DeepgramStreamAdapter connected successfully');
    } catch (error) {
      this.componentLogger.error('Failed to connect DeepgramStreamAdapter', { error });
      throw error;
    }
  }
  
  /**
   * DeepgramStreamAdapter „ÅÆ„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº„ÇíË®≠ÂÆö
   */
  private setupDeepgramEventHandlers(): void {
    if (!this.deepgramAdapter) return;
    
    // Transcript „Ç§„Éô„É≥„Éà
    this.deepgramAdapter.on(DeepgramStreamAdapter.EVENTS.TRANSCRIPT, (result: TranscriptResult) => {
      // TranscriptResult „ÇíÊó¢Â≠ò„ÅÆ TranscriptSegment ÂΩ¢Âºè„Å´Â§âÊèõ
      const segment: TranscriptSegment = {
        id: result.id,
        text: result.text,
        timestamp: result.timestamp,
        confidence: result.confidence,
        isFinal: result.isFinal,
        startMs: result.startMs,
        endMs: result.endMs
      };
      
      this.processTranscriptSegment(segment);
    });
    
    // Error „Ç§„Éô„É≥„Éà
    this.deepgramAdapter.on(DeepgramStreamAdapter.EVENTS.ERROR, (error: DeepgramError) => {
      this.componentLogger.error('Deepgram adapter error', { ...error });
      this.emitError('DEEPGRAM_ERROR', 
        error.message,
        this.currentCorrelationId || 'unknown'
      );
    });
    
    // Connected „Ç§„Éô„É≥„Éà
    this.deepgramAdapter.on(DeepgramStreamAdapter.EVENTS.CONNECTED, () => {
      this.componentLogger.info('Deepgram adapter connected event received');
    });
    
    // Disconnected „Ç§„Éô„É≥„Éà
    this.deepgramAdapter.on(DeepgramStreamAdapter.EVENTS.DISCONNECTED, (reason?: string) => {
      this.componentLogger.info('Deepgram adapter disconnected', { reason });
      // ÂøÖË¶Å„Å´Âøú„Åò„Å¶ÂÜçÊé•Á∂ö„É≠„Ç∏„ÉÉ„ÇØ„ÇíËøΩÂä†
    });
    
    // UtteranceEnd „Ç§„Éô„É≥„ÉàÔºàÂ∞ÜÊù•„ÅÆÂÆüË£ÖÁî®Ôºâ
    this.deepgramAdapter.on(DeepgramStreamAdapter.EVENTS.UTTERANCE_END, (data: any) => {
      this.componentLogger.debug('UtteranceEnd event received', data);
      // TODO: UtteranceEnd Âá¶ÁêÜ„ÅÆÂÆüË£Ö
    });
    
    // Metadata „Ç§„Éô„É≥„Éà
    this.deepgramAdapter.on(DeepgramStreamAdapter.EVENTS.METADATA, (metadata: any) => {
      this.componentLogger.debug('Deepgram metadata received', metadata);
    });
  }

  /**
   * Get meaning of WebSocket close code
   */


  /**
   * Process transcript segment - „Ç∑„É≥„Éó„É´„Å´Âá¶ÁêÜÔºàË¶™„Éï„Ç©„É´„ÉÄ„Å®ÂêåÊßòÔºâ
   */
  private processTranscriptSegment(segment: TranscriptSegment): void {
    // Store final segments only
    if (segment.isFinal) {
      this.transcriptSegments.push(segment);
      
      // Áõ¥Êé•ÁøªË®≥„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†ÔºàSegmentManager‰∏çË¶ÅÔºâ
      this.translateSegment(segment.text, segment.id);
      
      // SentenceCombiner„Å´ËøΩÂä†ÔºàÊñáÂçò‰Ωç„ÅÆÁµêÂêàÁî®Ôºâ
      this.sentenceCombiner.addSegment(segment);
    }
    
    // Emit ASR event for both interim and final results
    console.log('[UnifiedPipelineService] Emitting ASR event:', {
      text: segment.text,
      isFinal: segment.isFinal,
      segmentId: segment.id
    });
    this.emitEvent(createASREvent({
      text: segment.text,
      confidence: segment.confidence,
      isFinal: segment.isFinal,
      language: this.sourceLanguage,
      segmentId: segment.id, // Added for RealtimeDisplayManager
    }, this.currentCorrelationId || 'unknown'));
    
    // üî¥ CRITICAL: Ë¶™„Éï„Ç©„É´„ÉÄ„Å®Âêå„ÅòÁõ¥Êé•„Ç§„Éô„É≥„Éà„ÇÇÁô∫Ë°å
    // „É™„Ç¢„É´„Çø„Ç§„É†Ë°®Á§∫„ÅÆ„Åü„ÇÅ„Å´ÂøÖË¶ÅÔºàinterimÁµêÊûú„ÇÇÂê´„ÇÄÔºâ
    this.emit('currentOriginalUpdate', {
      text: segment.text,
      isFinal: segment.isFinal
    });
    
    // üî¥ CRITICAL: SegmentManagerÁµåÁî±„ÅÆÂá¶ÁêÜ„ÇíÂâäÈô§
    // ÈáçË§á„ÅÆÂéüÂõ†ÔºöSegmentManager„ÇÇÁøªË®≥„Çí„Éà„É™„Ç¨„Éº„Åô„Çã„Åü„ÇÅ„ÄÅ
    // Âêå„Åò„Çª„Ç∞„É°„É≥„Éà„Åå2ÂõûÁøªË®≥„Åï„Çå„Å¶„ÅÑ„Åü
    // Ë¶™„Éï„Ç©„É´„ÉÄÔºàUniVoice 1.0Ôºâ„Å®Âêå„Åò„Ç∑„É≥„Éó„É´„Å™ÂÆüË£Ö„Å´Êàª„Åô
  }

  /**
   * Translate segment text using queue
   * 
   * ÁøªË®≥„É™„ÇØ„Ç®„Çπ„Éà„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†„Åó„ÄÅ‰∏¶ÂàóÊï∞Âà∂Èôê„ÇíÈÅ©Áî®
   */
  private async translateSegment(text: string, segmentId: string): Promise<void> {
    try {
      // „Ç≠„É•„Éº„Å´ÁøªË®≥„É™„ÇØ„Ç®„Çπ„Éà„ÇíËøΩÂä†
      await this.translationQueue.enqueue({
        segmentId,
        originalText: text,
        sourceLanguage: this.sourceLanguage,
        targetLanguage: this.targetLanguage,
        timestamp: Date.now(),
        priority: 'normal' // ÈÄöÂ∏∏ÂÑ™ÂÖàÂ∫¶
      });
      
      this.componentLogger.info('Translation request queued', {
        segmentId,
        queueStatus: this.translationQueue.getStatus()
      });
    } catch (error) {
      this.componentLogger.error('Failed to queue translation', {
        segmentId,
        error: error instanceof Error ? error.message : String(error)
      });
      
      // „Ç®„É©„Éº„Ç§„Éô„É≥„Éà„ÇíÁô∫Ë°å
      this.emitEvent(createErrorEvent(
        {
          code: 'TRANSLATION_QUEUE_ERROR',
          message: `Translation queue error: ${error instanceof Error ? error.message : String(error)}`,
          recoverable: true
        },
        this.currentCorrelationId || 'unknown'
      ));
    }
  }
  
  /**
   * Execute translation (called by queue)
   * 
   * @see https://platform.openai.com/docs/api-reference/responses
   * @see docs/GPT5-RESPONSES-API-GUIDE.md - GPT-5 Responses API„ÅÆ‰ΩøÁî®ÊñπÊ≥ï
   * 
   * ÈáçË¶Å: Responses API„ÅØÂÆüÂú®„ÅÆAPI„Åß„ÅôÔºà2025Âπ¥3Êúà„É™„É™„Éº„ÇπÔºâ
   * - responses.stream „Çí‰ΩøÁî®Ôºàchat.completions.create„Åß„ÅØ„Å™„ÅÑÔºâ
   * - input„Éë„É©„É°„Éº„Çø„Çí‰ΩøÁî®Ôºàmessages„Åß„ÅØ„Å™„ÅÑÔºâ
   * - max_output_tokens„Çí‰ΩøÁî®Ôºàmax_tokens„Åß„ÅØ„Å™„ÅÑÔºâ
   * - reasoning.effort„ÅßÊé®Ë´ñ„ÅÆÊ∑±„Åï„ÇíÂà∂Âæ°Ôºàminimal/low/medium/highÔºâ
   * - temperature„ÅØ1.0Âõ∫ÂÆöÔºàGPT-5„Åß„ÅØÂ§âÊõ¥‰∏çÂèØÔºâ
   */
  private async executeTranslation(queuedTranslation: QueuedTranslation): Promise<string> {
    const startTime = Date.now();
    let firstPaintTime = 0;
    const segmentId = queuedTranslation.segmentId;
    const text = queuedTranslation.originalText;
    
    try {
      // üî¥ Ê≠£„Åó„ÅÑAPIÂëº„Å≥Âá∫„ÅóÊñπÊ≥ïÔºàtest-3min-complete.js„ÅßÂãï‰ΩúÁ¢∫Ë™çÊ∏à„ÅøÔºâ
      // responses.create „Çí‰ΩøÁî®Ôºàchat.completions.create„Åß„ÅØ„Å™„ÅÑÔºâ
      // „Åì„Çå„ÅåGPT-5Á≥ª„É¢„Éá„É´„ÅÆÊ≠£„Åó„ÅÑÂëº„Å≥Êñπ
      // ÂãïÁöÑ„Å´ÁøªË®≥„Éó„É≠„É≥„Éó„Éà„ÇíÁîüÊàê
      const translationPrompt = getTranslationPrompt(this.sourceLanguage, this.targetLanguage);
      
      const stream = await this.openai.responses.create({
        model: this.openaiConfig.models.translate,
        input: [
          { role: 'system', content: translationPrompt },
          { role: 'user', content: text }
        ],
        max_output_tokens: this.openaiConfig.maxTokens.translate,
        reasoning: { effort: 'minimal' },
        stream: true  // „Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„ÇíÊúâÂäπÂåñ
      });
      
      let translation = '';
      
      for await (const chunk of stream) {
        // test-3min-complete.js (517Ë°åÁõÆ) „Å´Ê∫ñÊã†
        if (chunk.type === 'response.output_text.delta' && chunk.delta) {
          const delta = chunk.delta;
          if (delta && !firstPaintTime) {
            firstPaintTime = Date.now() - startTime;
          }
          translation += delta;
          
          // ‚ë£Current JapaneseÊõ¥Êñ∞Ôºà„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞Ôºâ
          // ‰∏≠ÈñìÁµêÊûú„ÇÇÊúÄÁµÇÁµêÊûú„ÇÇ‰∏°Êñπ„É™„Ç¢„É´„Çø„Ç§„É†Ë°®Á§∫
          // SegmentManager„ÅØ‰Ωø„Çè„Å™„ÅÑ - Ë¶™„Éï„Ç©„É´„ÉÄ„Å®Âêå„Åò„Ç∑„É≥„Éó„É´„Å™Âá¶ÁêÜ
          
          // üî¥ CRITICAL: Ë¶™„Éï„Ç©„É´„ÉÄ„Å®Âêå„ÅòÁõ¥Êé•„Ç§„Éô„É≥„Éà„ÇÇÁô∫Ë°å
          // „É™„Ç¢„É´„Çø„Ç§„É†ÁøªË®≥Ë°®Á§∫„ÅÆ„Åü„ÇÅ„Å´ÂøÖË¶ÅÔºàÁ¥ØÁ©ç„Åï„Çå„ÅüÂÖ®‰Ωì„ÇíÈÄÅ‰ø°Ôºâ
          this.emit('currentTranslationUpdate', translation);
        }
      }
      
      const completeTime = Date.now() - startTime;
      
      // ÁøªË®≥ÂÆå‰∫Ü
      const result: Translation = {
        id: `translation-${segmentId}`,
        original: text,
        translated: translation.trim(),
        sourceLanguage: this.sourceLanguage,
        targetLanguage: this.targetLanguage,
        timestamp: Date.now(),
        confidence: 0.9, // OpenAI translations are generally high confidence
        isFinal: true,
      };
      
      this.translations.push(result);
      
      // üî¥ CRITICAL: SegmentManager„ÅØ‰Ωø„Çè„Å™„ÅÑ - Ë¶™„Éï„Ç©„É´„ÉÄ„Å®Âêå„Åò„Ç∑„É≥„Éó„É´„Å™Âá¶ÁêÜ
      // ÈáçË§á„ÅÆÂéüÂõ†„ÇíÂÆåÂÖ®„Å´ÊéíÈô§
      
      // Add translation to advanced features for summary generation
      this.advancedFeatures.addTranslation({
        id: result.id,
        original: result.original,
        translated: result.translated,
        timestamp: result.timestamp
      });
      
      // Emit translation event
      this.emitEvent(createTranslationEvent({
        originalText: result.original,
        translatedText: result.translated,
        sourceLanguage: result.sourceLanguage,
        targetLanguage: result.targetLanguage,
        confidence: result.confidence,
        isFinal: result.isFinal,
        segmentId: segmentId,
      }, this.currentCorrelationId || 'unknown'));
      
      // üî¥ CRITICAL: Ë¶™„Éï„Ç©„É´„ÉÄ‰∫íÊèõ„ÅÆtranslationComplete„Ç§„Éô„É≥„Éà„ÇíÁô∫ÁÅ´
      // „Åì„ÅÆ„Ç§„Éô„É≥„Éà„Åå„Å™„ÅÑ„Å®Â±•Ê≠¥„Å´ËøΩÂä†„Åï„Çå„Å™„ÅÑ
      if (result.isFinal) {
        this.emit('translationComplete', {
          id: segmentId,
          original: result.original,
          japanese: result.translated,
          timestamp: Date.now(),
          firstPaintMs: firstPaintTime,
          completeMs: completeTime
        });
      }
      
      // ÊàêÂäü„É°„Éà„É™„ÇØ„Çπ
      console.log(`[ÁøªË®≥ÂÆå‰∫Ü] "${result.translated.substring(0, 30)}..." (${completeTime}ms)`);
      
      this.componentLogger.performance('info', 'Translation completed', startTime, {
        textLength: text.length,
        translationLength: result.translated.length,
        segmentId,
        firstPaintMs: firstPaintTime,
        completeMs: completeTime,
      });
      
      // üî¥ Shadow Mode: LLM GatewayÁµåÁî±„Åß„ÇÇÂÆüË°åÔºàÊó¢Â≠òÂÆüË£Ö„Å´ÂΩ±Èüø„Åó„Å™„ÅÑÔºâ
      if (this.enableShadowMode && this.llmGateway) {
        this.executeShadowModeTranslation(text, segmentId, result.translated, firstPaintTime, completeTime);
      }
      
      // Return the translated text for the queue
      return result.translated;
      
    } catch (error: any) {
      console.error('[UnifiedPipeline] Translation error:', error);
      console.error('[UnifiedPipeline] Error details:', {
        message: error.message,
        code: error.code,
        status: error.status,
        response: error.response?.data
      });
      
      this.componentLogger.error('Translation failed', {
        error: error instanceof Error ? error.message : String(error),
        text: text.substring(0, 100),
        segmentId,
      });
      
      this.emitEvent(createErrorEvent(
        {
          code: 'TRANSLATION_FAILED',
          message: `Failed to translate segment: ${error instanceof Error ? error.message : 'Unknown error'}`,
          recoverable: false
        },
        this.currentCorrelationId || 'unknown'
      ));
      
      // Re-throw to let the queue handle the error
      throw error;
    }
  }

  /**
   * Set pipeline state and emit status event
   */
  private setState(newState: PipelineState): void {
    const oldState = this.state;
    this.state = newState;
    
    this.componentLogger.info('Pipeline state changed', {
      from: oldState,
      to: newState,
      correlationId: this.currentCorrelationId,
    });
    
    // Emit status event
    this.emitEvent(createStatusEvent({
      state: newState,
      details: {
        previousState: oldState,
        timestamp: Date.now(),
        uptime: this.startTime > 0 ? Date.now() - this.startTime : 0,
      },
    }, this.currentCorrelationId || 'unknown'));
  }

  /**
   * Emit pipeline event
   */
  private emitEvent(event: PipelineEvent): void {
    this.emit('pipelineEvent', event);
  }

  /**
   * Emit error event
   */
  private emitError(code: string, message: string, correlationId: string): void {
    this.emitEvent(createErrorEvent({
      code,
      message,
      recoverable: true,
      details: {
        state: this.state,
        timestamp: Date.now(),
      },
    }, correlationId));
  }


  /**
   * Generate vocabulary from current session
   */
  public async generateVocabulary(correlationId: string): Promise<void> {
    try {
      this.componentLogger.info('Generating vocabulary', { correlationId });
      
      const vocabulary = await this.advancedFeatures.generateVocabulary();
      
      if (vocabulary.length > 0) {
        this.emitEvent(createVocabularyEvent({
          items: vocabulary,
          totalTerms: vocabulary.length,
        }, correlationId));
        
        this.componentLogger.info('Vocabulary generated', {
          correlationId,
          termCount: vocabulary.length,
        });
      } else {
        this.componentLogger.warn('No vocabulary items generated', { correlationId });
      }
    } catch (error) {
      this.componentLogger.error('Failed to generate vocabulary', {
        error: error instanceof Error ? error.message : String(error),
        correlationId,
      });
      
      this.emitError('VOCABULARY_GENERATION_FAILED',
        `Failed to generate vocabulary: ${error instanceof Error ? error.message : 'Unknown error'}`,
        correlationId
      );
    }
  }

  /**
   * Generate final report from current session
   */
  public async generateFinalReport(correlationId: string): Promise<void> {
    try {
      this.componentLogger.info('Generating final report', { correlationId });
      
      const report = await this.advancedFeatures.generateFinalReport();
      
      if (report) {
        const totalWordCount = this.translations.reduce(
          (sum, t) => sum + t.original.split(' ').length, 
          0
        );
        const summaryCount = this.advancedFeatures.getSummaries().length;
        const vocabularyCount = (await this.advancedFeatures.generateVocabulary()).length;
        
        this.emitEvent(createFinalReportEvent({
          report,
          totalWordCount,
          summaryCount,
          vocabularyCount,
        }, correlationId));
        
        this.componentLogger.info('Final report generated', {
          correlationId,
          reportLength: report.length,
          totalWordCount,
          summaryCount,
        });
      } else {
        this.componentLogger.warn('Empty final report generated', { correlationId });
      }
    } catch (error) {
      this.componentLogger.error('Failed to generate final report', {
        error: error instanceof Error ? error.message : String(error),
        correlationId,
      });
      
      this.emitError('FINAL_REPORT_GENERATION_FAILED',
        `Failed to generate final report: ${error instanceof Error ? error.message : 'Unknown error'}`,
        correlationId
      );
    }
  }
  
  /**
   * Handle combined sentence from SentenceCombiner
   * ÁµêÂêà„Åï„Çå„ÅüÊñá„ÇíÂ±•Ê≠¥Áî®È´òÂìÅË≥™ÁøªË®≥„Ç≠„É•„Éº„Å´ËøΩÂä†
   */
  private async handleCombinedSentence(combinedSentence: CombinedSentence): Promise<void> {
    console.log(`[UnifiedPipelineService] Combined sentence ready: ${combinedSentence.segmentCount} segments`);
    
    try {
      // Â±•Ê≠¥Áî®ÁøªË®≥„É™„ÇØ„Ç®„Çπ„Éà„Çí‰ΩéÂÑ™ÂÖàÂ∫¶„Åß„Ç≠„É•„Éº„Å´ËøΩÂä†
      await this.translationQueue.enqueue({
        segmentId: `history_${combinedSentence.id}`,
        originalText: combinedSentence.originalText,
        sourceLanguage: this.sourceLanguage,
        targetLanguage: this.targetLanguage,
        timestamp: combinedSentence.timestamp,
        priority: 'low'  // ‰ΩéÂÑ™ÂÖàÂ∫¶„Åß„É™„Ç¢„É´„Çø„Ç§„É†ÁøªË®≥„ÇíÂ¶®„Åí„Å™„ÅÑ
      });
      
      console.log(`[UnifiedPipelineService] History translation queued for combined sentence: ${combinedSentence.id}`);
    } catch (error) {
      console.error('[UnifiedPipelineService] Failed to queue history translation:', error);
      // Â±•Ê≠¥ÁøªË®≥„ÅÆÂ§±Êïó„ÅØ„É™„Ç¢„É´„Çø„Ç§„É†ÁøªË®≥„Å´ÂΩ±Èüø„Åó„Å™„ÅÑ„Çà„ÅÜ„Å´„Ç®„É©„Éº„ÇíÊè°„Çä„Å§„Å∂„Åô
    }
  }
  
  /**
   * Execute history translation with higher quality
   * Â±•Ê≠¥Áî®„ÅÆÈ´òÂìÅË≥™ÁøªË®≥„ÇíÂÆüË°åÔºà„Çà„ÇäÂ§ß„Åç„Å™„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Å®È´òÂìÅË≥™„É¢„Éá„É´Ôºâ
   */
  private async executeHistoryTranslation(queuedTranslation: QueuedTranslation): Promise<string> {
    const startTime = Date.now();
    const combinedId = queuedTranslation.segmentId.replace('history_', '');
    const text = queuedTranslation.originalText;
    
    try {
      console.log(`[UnifiedPipelineService] Starting history translation for: ${combinedId}`);
      
      // Â±•Ê≠¥Áî®„ÅÆË©≥Á¥∞„Å™ÁøªË®≥„Éó„É≠„É≥„Éó„Éà
      const historyTranslationPrompt = `„ÅÇ„Å™„Åü„ÅØ${this.sourceLanguage}„Åã„Çâ${this.targetLanguage}„Å∏„ÅÆÂ∞ÇÈñÄÁøªË®≥ËÄÖ„Åß„Åô„ÄÇ
‰ª•‰∏ã„ÅÆË¨õÁæ©ÂÜÖÂÆπ„Çí„ÄÅÊñáËÑà„ÇíËÄÉÊÖÆ„Åó„Å¶Ëá™ÁÑ∂„ÅßÊ≠£Á¢∫„Å™${this.targetLanguage}„Å´ÁøªË®≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

ÈáçË¶Å„Å™ÊåáÁ§∫:
1. Â∞ÇÈñÄÁî®Ë™û„ÅØÊ≠£Á¢∫„Å´ÁøªË®≥„Åó„ÄÅÂøÖË¶Å„Å´Âøú„Åò„Å¶ÂéüË™û„Çí‰ΩµË®ò
2. Êñá„ÅÆÊµÅ„Çå„ÇíËá™ÁÑ∂„Å´„Åó„ÄÅË¨õÁæ©„Å®„Åó„Å¶ËÅû„Åç„ÇÑ„Åô„ÅÑË°®Áèæ„Å´
3. Ë§áÊï∞„ÅÆÊñá„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅÊñáËÑà„ÇíËÄÉÊÖÆ„Åó„Å¶‰∏ÄË≤´ÊÄß„ÅÆ„ÅÇ„ÇãÁøªË®≥„Å´
4. Â≠¶Áîü„ÅåÁêÜËß£„Åó„ÇÑ„Åô„ÅÑ„Çà„ÅÜ„ÄÅÈÅ©Âàá„Å™Ë™¨Êòé„ÇíÂä†„Åà„Å¶„ÇÇÊßã„ÅÑ„Åæ„Åõ„Çì`;
      
      // È´òÂìÅË≥™„É¢„Éá„É´„ÅßÁøªË®≥Ôºàgpt-5-mini„Åæ„Åü„ÅØgpt-5Ôºâ
      const stream = await this.openai.responses.create({
        model: this.openaiConfig.models.summary,  // È´òÂìÅË≥™„É¢„Éá„É´„Çí‰ΩøÁî®
        input: [
          { role: 'system', content: historyTranslationPrompt },
          { role: 'user', content: text }
        ],
        max_output_tokens: 2000,  // „Çà„ÇäÈï∑„ÅÑÂá∫Âäõ„ÇíË®±ÂèØ
        reasoning: { effort: 'low' },  // Â∞ë„ÅóÊé®Ë´ñ„ÇíÂº∑Âåñ
        stream: true
      });
      
      let translation = '';
      
      for await (const chunk of stream) {
        if (chunk.type === 'response.output_text.delta' && chunk.delta) {
          translation += chunk.delta;
        }
      }
      
      const completeTime = Date.now() - startTime;
      console.log(`[UnifiedPipelineService] History translation completed in ${completeTime}ms`);
      
      // Â±•Ê≠¥ÁøªË®≥ÂÆå‰∫Ü„Ç§„Éô„É≥„Éà„ÇíÁô∫Ë°åÔºàpipelineEvent„Å®„Åó„Å¶Ôºâ
      this.emitEvent(createTranslationEvent({
        originalText: text,
        translatedText: translation.trim(),
        sourceLanguage: this.sourceLanguage,
        targetLanguage: this.targetLanguage,
        confidence: 0.95,  // È´òÂìÅË≥™ÁøªË®≥„Å™„ÅÆ„ÅßÈ´ò‰ø°È†ºÂ∫¶
        isFinal: true,
        segmentId: `history_${combinedId}`,  // Â±•Ê≠¥ÁøªË®≥„Åß„ÅÇ„Çã„Åì„Å®„ÇíË≠òÂà•
      }, this.currentCorrelationId || 'unknown'));
      
      // üî¥ Shadow Mode: LLM GatewayÁµåÁî±„Åß„ÇÇÂÆüË°åÔºàÊó¢Â≠òÂÆüË£Ö„Å´ÂΩ±Èüø„Åó„Å™„ÅÑÔºâ
      if (this.enableShadowMode && this.llmGateway) {
        this.executeShadowModeHistoryTranslation(text, combinedId, translation.trim(), completeTime);
      }
      
      return translation.trim();
      
    } catch (error: any) {
      console.error('[UnifiedPipelineService] History translation error:', error);
      
      // Â±•Ê≠¥ÁøªË®≥„ÅÆÂ§±Êïó„ÅØËá¥ÂëΩÁöÑ„Åß„ÅØ„Å™„ÅÑ„ÅÆ„Åß„ÄÅ„Ç®„É©„Éº„ÇíË®òÈå≤„Åô„Çã„Å†„Åë
      this.componentLogger.warn('History translation failed', {
        error: error instanceof Error ? error.message : String(error),
        combinedId,
        textLength: text.length
      });
      
      // Á©∫„ÅÆÁøªË®≥„ÇíËøî„ÅôÔºàÂÖÉ„ÅÆ„Çª„Ç∞„É°„É≥„ÉàÁøªË®≥„Åå‰ΩøÁî®„Åï„Çå„ÇãÔºâ
      return '';
    }
  }
  
  /**
   * Shadow Mode: ÈÄöÂ∏∏ÁøªË®≥„ÅÆÊØîËºÉÂÆüË°åÔºàÈùûÂêåÊúü„Éª„Ç®„É©„Éº„ÇíÊè°„Çä„Å§„Å∂„ÅôÔºâ
   * 
   * @private
   */
  private async executeShadowModeTranslation(
    text: string, 
    segmentId: string, 
    originalTranslation: string, 
    originalFirstPaintMs: number, 
    originalCompleteMs: number
  ): Promise<void> {
    try {
      const shadowStartTime = Date.now();
      let shadowFirstPaintTime = 0;
      let shadowTranslation = '';
      
      // LLM GatewayÁµåÁî±„Åß„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞ÁøªË®≥
      const translationPrompt = getTranslationPrompt(this.sourceLanguage, this.targetLanguage);
      const stream = this.llmGateway!.stream({
        purpose: LLMPurpose.TRANSLATION,
        systemPrompt: translationPrompt,
        userContent: text,
        metadata: { segmentId, shadowMode: true }
      });
      
      for await (const chunk of stream) {
        if (!chunk.isComplete) {
          if (!shadowFirstPaintTime && chunk.delta) {
            shadowFirstPaintTime = Date.now() - shadowStartTime;
          }
          shadowTranslation += chunk.delta;
        }
      }
      
      const shadowCompleteTime = Date.now() - shadowStartTime;
      
      // ÁµêÊûú„ÇíÊØîËºÉ„Åó„Å¶„É≠„Ç∞Âá∫Âäõ
      const comparison = {
        segmentId,
        textLength: text.length,
        original: {
          translation: originalTranslation.substring(0, 100) + '...',
          firstPaintMs: originalFirstPaintMs,
          completeMs: originalCompleteMs
        },
        shadow: {
          translation: shadowTranslation.substring(0, 100) + '...',
          firstPaintMs: shadowFirstPaintTime,
          completeMs: shadowCompleteTime,
          metrics: this.llmGateway!.getLastMetrics()
        },
        match: originalTranslation.trim() === shadowTranslation.trim(),
        performanceDelta: {
          firstPaint: shadowFirstPaintTime - originalFirstPaintMs,
          complete: shadowCompleteTime - originalCompleteMs
        }
      };
      
      this.componentLogger.info('Shadow Mode translation comparison', comparison);
      
    } catch (error) {
      // Shadow Mode„ÅÆ„Ç®„É©„Éº„ÅØÊú¨Áï™„Å´ÂΩ±Èüø„Åó„Å™„ÅÑ„Çà„ÅÜÊè°„Çä„Å§„Å∂„Åô
      this.componentLogger.error('Shadow Mode translation failed', {
        error: error instanceof Error ? error.message : String(error),
        segmentId
      });
    }
  }
  
  /**
   * Shadow Mode: Â±•Ê≠¥ÁøªË®≥„ÅÆÊØîËºÉÂÆüË°åÔºàÈùûÂêåÊúü„Éª„Ç®„É©„Éº„ÇíÊè°„Çä„Å§„Å∂„ÅôÔºâ
   * 
   * @private
   */
  private async executeShadowModeHistoryTranslation(
    text: string,
    combinedId: string,
    originalTranslation: string,
    originalCompleteMs: number
  ): Promise<void> {
    try {
      const shadowStartTime = Date.now();
      
      // LLM GatewayÁµåÁî±„ÅßÈ´òÂìÅË≥™ÁøªË®≥
      const historyPrompt = `„ÅÇ„Å™„Åü„ÅØ${this.sourceLanguage}„Åã„Çâ${this.targetLanguage}„Å∏„ÅÆÂ∞ÇÈñÄÁøªË®≥ËÄÖ„Åß„Åô„ÄÇ
‰ª•‰∏ã„ÅÆË¨õÁæ©ÂÜÖÂÆπ„Çí„ÄÅÊñáËÑà„ÇíËÄÉÊÖÆ„Åó„Å¶Ëá™ÁÑ∂„ÅßÊ≠£Á¢∫„Å™${this.targetLanguage}„Å´ÁøªË®≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

ÈáçË¶Å„Å™ÊåáÁ§∫:
1. Â∞ÇÈñÄÁî®Ë™û„ÅØÊ≠£Á¢∫„Å´ÁøªË®≥„Åó„ÄÅÂøÖË¶Å„Å´Âøú„Åò„Å¶ÂéüË™û„Çí‰ΩµË®ò
2. Êñá„ÅÆÊµÅ„Çå„ÇíËá™ÁÑ∂„Å´„Åó„ÄÅË¨õÁæ©„Å®„Åó„Å¶ËÅû„Åç„ÇÑ„Åô„ÅÑË°®Áèæ„Å´
3. Ë§áÊï∞„ÅÆÊñá„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅÊñáËÑà„ÇíËÄÉÊÖÆ„Åó„Å¶‰∏ÄË≤´ÊÄß„ÅÆ„ÅÇ„ÇãÁøªË®≥„Å´
4. Â≠¶Áîü„ÅåÁêÜËß£„Åó„ÇÑ„Åô„ÅÑ„Çà„ÅÜ„ÄÅÈÅ©Âàá„Å™Ë™¨Êòé„ÇíÂä†„Åà„Å¶„ÇÇÊßã„ÅÑ„Åæ„Åõ„Çì`;
      
      const response = await this.llmGateway!.complete({
        purpose: LLMPurpose.SUMMARY,  // È´òÂìÅË≥™„É¢„Éá„É´„Çí‰ΩøÁî®
        systemPrompt: historyPrompt,
        userContent: text,
        maxTokens: 2000,
        metadata: { combinedId, shadowMode: true, historyTranslation: true }
      });
      
      const shadowCompleteTime = Date.now() - shadowStartTime;
      
      // ÁµêÊûú„ÇíÊØîËºÉ„Åó„Å¶„É≠„Ç∞Âá∫Âäõ
      const comparison = {
        combinedId,
        textLength: text.length,
        original: {
          translation: originalTranslation.substring(0, 100) + '...',
          completeMs: originalCompleteMs
        },
        shadow: {
          translation: response.content.substring(0, 100) + '...',
          completeMs: shadowCompleteTime,
          metrics: this.llmGateway!.getLastMetrics()
        },
        match: originalTranslation.trim() === response.content.trim(),
        performanceDelta: shadowCompleteTime - originalCompleteMs
      };
      
      this.componentLogger.info('Shadow Mode history translation comparison', comparison);
      
    } catch (error) {
      // Shadow Mode„ÅÆ„Ç®„É©„Éº„ÅØÊú¨Áï™„Å´ÂΩ±Èüø„Åó„Å™„ÅÑ„Çà„ÅÜÊè°„Çä„Å§„Å∂„Åô
      this.componentLogger.error('Shadow Mode history translation failed', {
        error: error instanceof Error ? error.message : String(error),
        combinedId
      });
    }
  }
  
  /**
   * Cleanup resources
   */
  destroy(): void {
    if (this.deepgramAdapter) {
      this.deepgramAdapter.disconnect();
      this.deepgramAdapter.destroy();
      this.deepgramAdapter = null;
    }
    
    // üî¥ CRITICAL: SegmentManager.destroy()„ÇíÂâäÈô§
    // this.segmentManager.destroy();
    this.advancedFeatures.destroy();
    this.translationQueue.destroy();
    this.sentenceCombiner.destroy();
    this.removeAllListeners();
    
    this.componentLogger.info('UnifiedPipelineService destroyed');
  }
}